<?xml version="1.0" encoding="utf-8"?>
<ArrayOfProgramBlock xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <ProgramBlock>
    <ScriptSetup>var dataFolder = Data.GetFolder(PresetsFolder);
Data.AddToSystemBackup(dataFolder);
Program.Run();
</ScriptSetup>
    <ScriptSource>var dataFolder = Data.GetFolder(PresetsFolder);

Api.Handle($"{apiBaseUrl}List", (args) =&gt; {
    var files = Directory.GetFiles(dataFolder);
    return files.Select(f =&gt; Path.GetFileNameWithoutExtension(f));
});
Api.Handle($"{apiBaseUrl}Add/", (args) =&gt; {
    var command = Api.Parse(args);
    if (command.Data != null) {
        var configuration = System.Text.Encoding.Default.GetString(command.Data as byte[]);
        var presetName = command.GetOption(0);
        if (String.IsNullOrEmpty(presetName)) {
            presetName = "default";
        }
        var dataFile = Path.Combine(dataFolder, presetName + ".json");
        File.WriteAllText(dataFile, configuration);
    }
    return new ResponseStatus(Status.Ok);
});
Api.Handle($"{apiBaseUrl}Get/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        presetName = "default";
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    var config = "{config: null, preferences: null}";
    if (File.Exists(dataFile)) config = File.ReadAllText(dataFile);
    return config;
});
Api.Handle($"{apiBaseUrl}Delete/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        return new ResponseStatus(Status.Error);
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    File.Delete(dataFile);
    return new ResponseStatus(Status.Ok);
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string PresetsFolder = "client-presets";
const string apiBaseUrl = "HomeAutomation.HomeGenie/Config/Client.Presets";
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>client-configs</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>0BE01D06C8342351AC31E74439BA6022</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>111</Address>
    <Name>Client configuration</Name>
    <Description>Implements API for managing client's configuration profiles that are used to store client's UI and dashboards settings.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements("@Statistics:Provider", apiUrl, new {
    icon = "legend_toggle"
}).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = dataApiUrl,
        scale = "time",
        filters = new string[] {
            "SimpleAverage",
            "MovingAverage",
            "SavitzkyGolay"
        }
    };
});

Api.Handle($"{dataApiUrl}/SimpleAverage", (args) =&gt; {
    var request = Api.Parse(args);
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var stats = ApplySimpleAverageFilter(parameter, startTime, endTime, chartWidth);
        stats.History.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{dataApiUrl}/MovingAverage", (args) =&gt; {
    var request = Api.Parse(args);
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new MovingAverageFilter(windowSize);
        var stats = ApplyFilter(filter, parameter, startTime, endTime, chartWidth);
        stats.History.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{dataApiUrl}/SavitzkyGolay", (args) =&gt; {
    var request = Api.Parse(args);
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new SavitzkyGolayFilter(windowSize);
        var stats = ApplyFilter(filter, parameter, startTime, endTime, chartWidth);
        stats.History.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/DataMonitor";
const string dataApiUrl = "DataProcessing.Filters/Series";

const int windowSize = 9;

ValueStatistics ApplySimpleAverageFilter(ModuleParameter parameter, double startTime, double endTime, double chartWidth) {
    startTime = (long)startTime;
    endTime = (long)endTime;

    // Copy parameter values history to a new object
    var stats = new ValueStatistics() {
        History = new TsList&lt;ValueStatistics.StatValue&gt;(
            parameter.Statistics.History
                .Where(sv =&gt; sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
                    .ToList()
        )
    };
    stats.History.Reverse();

    // Process time series
    if (startTime &gt; 0 &amp;&amp; stats.History.Count &gt; 0 &amp;&amp; chartWidth &lt; stats.History.Count)
    {
        var cts = stats.History.First().UnixTimestamp;
        var cte = stats.History.Last().UnixTimestamp;
        var stepMs = ((endTime - startTime) / chartWidth) * ((cte - cts) / (endTime - startTime));
        if (stepMs &lt; 1000) stepMs = 1000;
        var resampledList = new List&lt;ValueStatistics.StatValue&gt;();
        cts -= (cts % stepMs);
        cts -= stepMs;
        var sum = 0D;
        var count = 0;
        int i = 0;
        var itemTimestamp = DateTime.UtcNow;
        while (i &lt; stats.History.Count)
        {
            var item = stats.History[i];
            if (item.UnixTimestamp &gt;= cts)
            {
                var resampled = new ValueStatistics.StatValue(
                    sum / count,
                    itemTimestamp
                );
                resampledList.Add(resampled);
                sum =0; count = 0;
                cts += stepMs;
            }
            sum += item.Value;
            itemTimestamp = item.Timestamp;
            count++;
            i++;
        }
        stats.History = new TsList&lt;ValueStatistics.StatValue&gt;(resampledList);
    }
    return stats;
}

ValueStatistics ApplyFilter(NWaves.Filters.Base.IFilter filter, ModuleParameter parameter, double startTime, double endTime, double chartWidth) {
    var timeSpan = (endTime - startTime);
    var timeSpanMin = (timeSpan / 2);
    var stats = ApplySimpleAverageFilter(parameter, startTime - timeSpanMin, endTime + timeSpanMin, chartWidth);

    // Process time series
    var samples = stats.History
        .Select(sv =&gt; (float)sv.Value)
        .ToArray();
    var signal = new DiscreteSignal(50/*Hz sampling rate*/, samples);
    var smoothedSignal = filter.ApplyTo(signal);
    var lst = new List&lt;ValueStatistics.StatValue&gt;();
    int boundsGap = (windowSize - 1) / 2;
    for (int c = 0; c &lt; stats.History.Count - boundsGap; c++)
    {
        var sv = stats.History[c];
        if (sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
        {
            lst.Add(new ValueStatistics.StatValue(smoothedSignal[c + boundsGap], sv.Timestamp));
        }
    }

    stats.History = new TsList&lt;ValueStatistics.StatValue&gt;(lst);
    return stats;
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>stats-data-monitor</Id>
      <Version>1.0.3</Version>
      <Required>true</Required>
      <Checksum>C43D945F1D855C164EA2FECB6927A093</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>570</Address>
    <Name>Data Monitor</Name>
    <Description>Real-time data visualization and monitoring.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddOption("Email.Sender", "", "1. E-Mail address", "text")
  .AddOption("Email.SmtpServer", "", "2. SMTP Mail Server address", "text")
  .AddOption("Email.SmtpUserName", "", "3. SMTP username (optional)", "text")
  .AddOption("Email.SmtpPassword", "", "4. SMTP password (optional)", "password")
  .AddOption("Email.SmtpPort", "25", "5. SMTP Mail Server port", "text")
  .AddOption("Email.SmtpUseSsl", "false", "6. SMTP Mail Server use SSL", "checkbox")
  .Run();
</ScriptSetup>
    <ScriptSource>// detect when an option of this program is changed and store the new value to system settings
When.ModuleParameterChanged((module, parameter)=&gt;{
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
	var settingName = parameter.Name.Substring(17); // skip "ConfigureOptions." part
    Settings.Parameter("Messaging."+settingName).Value = parameter.Value;
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>e-mail-account</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>D5ED1400F10DBDA875BE6EDCE779EB46</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>142</Address>
    <Name>E-Mail Account</Name>
    <Description>Stores e-mail account information used for sending/receiving emails programatically.</Description>
    <Group>Messaging and Social</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements(
    "@Statistics:Provider",
    apiUrl,
    new {
        mode = "select_module",
        field = "Meter.Watts.Hour",
        type = "bar",
        title = "W/h",
        icon = "analytics"
    }
).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = apiDataUrl,
        scale = "linear",
        labels = new string[] {
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
            "Sun"
        }
    };
});

Api.Handle(apiDataUrl, (args) =&gt; {
    var request = Api.Parse(args);
    return GetWeeklyStats(request.Domain, request.Address);
    /*
    return new double[] {
        1, 2, 3, 4, 5, 6, 7
    };
    */
});

while (Program.IsRunning)
{

    // Calculates for each module average Watt consumption every hour
    var now = DateTime.UtcNow;
    var monitorModules = Modules.WithFeature("EnergyManagement.MonitorWatts");
    monitorModules.Each((mod) =&gt; {

        double defaultValue = mod.Parameter("Meter.Watts").Statistics.Current.Value;

        var records = mod.Parameter("Meter.Watts").Statistics.History
            .FindAll(sv =&gt; sv.Value &gt;= 0 &amp;&amp; (now - sv.Timestamp).TotalSeconds &lt; UpdateInterval);
        var avgWatt = records
            .Select(sv =&gt; sv.Value)
            .DefaultIfEmpty(defaultValue)
            .Average();

        mod.Emit("Meter.Watts.Hour", avgWatt);

        // store to database
        UpdateDatabase(mod.Instance, "Meter.Watts.Hour", avgWatt);

        return false;

    });

    // Update stats every minute
    Pause(60); 

}
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/WeeklyStats";
const string apiDataUrl = "DataProcessing.Statistics/Weekly/Meter.Watts.Hour";

const int UpdateInterval = 3600; // 1 hour
const string DbTable = "weekly";

class WeeklyStat {
    [BsonId]
    public Int32 ID { get; set; }
    public string Domain { get; set; }
    public string Address { get; set; }
    public byte DayHour { get; set; }
    public byte WeekDay { get; set; }
    public ushort YearWeek { get; set; }
    public string Parameter { get; set; }
    public double WattsHour { get; set; }

    public WeeklyStat() {}
    public WeeklyStat(string domain, string address, string p, double v, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
    {
        Domain = domain;
        Address = address;
        Parameter = p;
        WattsHour = v;
        YearWeek = weekOfYear;
        WeekDay = dayOfWeek;
        DayHour = hourOfDay;
    }
}

bool UpdateDatabase(Module m, string p, double v)
{
    UpdateWeeklyStat(m.Domain, m.Address, p, v, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now), (byte)DateTime.Now.DayOfWeek, (byte)DateTime.Now.Hour);
    return true;
}

bool UpdateWeeklyStat(string domain, string address, string parameter, double wattsHour, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
{
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        var record = stats.FindOne(x =&gt;
                        x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.Parameter == parameter
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == dayOfWeek
                        &amp;&amp; x.DayHour == hourOfDay
                    );
        if (record == null)
        {
            stats.Insert(new WeeklyStat(
                domain,
                address,
                parameter,
                wattsHour,
                weekOfYear,
                dayOfWeek,
                hourOfDay
            ));
        }
        else
        {
            record.WattsHour = wattsHour;
            stats.Update(record);
        }
    }
    return true;
}

double[] GetWeeklyStats(string domain, string address)
{
    var results = new double[7];
    var weekOfYear = (ushort)ISOWeek.GetWeekOfYear(DateTime.Now);
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        for (byte i = 0; i &lt; results.Length; i++)
        {
            var sumValues = stats
                .Find(x =&gt; x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == i);
//                .Sum(x =&gt; x.WattsHour); // &lt;-- this doesn't work with Mono runtime 
            double sum = 0;
            foreach(var s in sumValues) {
                sum += s.WattsHour;
            }
            /*    .Select(x =&gt; x.WattsHour)
                  .DefaultIfEmpty(0)
                  .Average();*/
            double avg = sum / 24.0;
            results[i == 0 ? 6 : i - 1] = avg;
        }
    }
    return results;
}

string GetDbName()
{
    return $"energy_use_{DateTime.Now.Year}.db";
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>energy-use-statistics</Id>
      <Version>1.0.5</Version>
      <Required>false</Required>
      <Checksum>86D69533E0D3CF36B570979B676193B0</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>571</Address>
    <Name>Energy use statistics</Name>
    <Description>Monitors and collects data on energy consumption. Also implements a bar chart to visualize data.

</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program.AddFeature("", "", EventsLoggingFeature, "Enable events logging", "checkbox");
});
Program.Run();
</ScriptSetup>
    <ScriptSource>var loggableModules = Modules.WithFeature(EventsLoggingFeature);

When.ProgramStopping(() =&gt; {
//  db.Dispose(); 
  return true;
});

When.ModuleParameterChanged((mod, p) =&gt; {
  var m = mod.Get().Instance;
  if (loggableModules.SelectedModules.Contains(m)) {
    lock(mod.Get().Instance)
    using (var db = Data.LiteDb(m.Domain+"@"+m.Address+"-events-log")) {
      db.Pragma("LIMIT_SIZE", 2097152);
      var col = db.GetCollection&lt;LoggerEvent&gt;("events");
      col.EnsureIndex(x =&gt; x.Domain);
      col.EnsureIndex(x =&gt; x.Address);
      col.EnsureIndex(x =&gt; x.Parameter);
      try {
        col.Insert(new LoggerEvent(m, p));
      } catch (Exception e) {
        // insert error, remove some data
        var col2 = db.GetCollection("events");
        var data_list = col2.Find(Query.All(), 0, 100);
        foreach (var row in data_list) 
        {
          col2.Delete(row["_id"]);
        }        
        // retry insert
        col.Insert(new LoggerEvent(m, p));
      }
    }
  }
  return true;
});

Api.Handle("HomeGenie.EventsLogger", (args) =&gt; {
  var cmd = Api.Parse(args);
  var moduleDomain = cmd.Address;
  var moduleAddress = cmd.Command;
  var module = Modules.InDomain(moduleDomain).WithAddress(moduleAddress);
  var parameter = cmd.GetOption(0);
  lock(module.Get().Instance)
  using (var db = Data.LiteDb(moduleDomain+"@"+moduleAddress+"-events-log")) {
    db.Pragma("LIMIT_SIZE", 2097152);
    var col = db.GetCollection&lt;LoggerEvent&gt;("events");
    var results = col.Query()
      .Where(x =&gt; x.Parameter == parameter)
      .OrderByDescending(x =&gt; x.Date)
      //.Select(x =&gt; new { x.Name, NameUpper = x.Name.ToUpper() }) // &lt;-- transform data
      .Limit(100)
      .ToList();
  	return results;
  }
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string EventsLoggingFeature = "EventsLogger.EnableLogging";</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>events-logging</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>45CFE6FF025BD92488BBDBE491C4C98D</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>95</Address>
    <Name>Events logging</Name>
    <Description>Records device activity.</Description>
    <Group>Security</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes />
        <Property>EventsLogger.EnableLogging</Property>
        <Description>Enable events logging</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program
    .AddOption("ClientId", Program.SystemId, "0. Unique ID for this client", "text")
    .AddOption("ServerAddress", "", "1. MQTT server address", "text")
    .AddOption("ServerPort", "1883", "2. MQTT server port", "text")
    .AddOption("Encryption", "", "3. End-to-end message encryption (E2EE)", "checkbox")
    .AddOption("EncryptionKey", "", "Encryption key", "hidden")
    .AddOption("WebSockets", "", "4. Use WebSockets", "checkbox")
    .AddOption("TLS", "", "5. Enable TLS/SSL", "checkbox")
    .AddOption("Username", "", "6. Username (optional)", "text")
    .AddOption("Password", "", "7. Password (optional)", "text")
    .AddOption("ImportExternal", "", "8. Import external modules", "checkbox");
});

encryptionKey = Program.Option("EncryptionKey").Value;

Program.Run();
</ScriptSetup>
    <ScriptSource>string server = Program.Option("ServerAddress").Value.Trim();
int port = 1883; int.TryParse(Program.Option("ServerPort").Value, out port);
string clientid = Program.Option("ClientId").Value.Trim();
string username = Program.Option("Username").Value.Trim();
string password = Program.Option("Password").Value.Trim();
bool useWebSockets = Program.Option("WebSockets").Value == "On";
bool useTls = Program.Option("TLS").Value == "On";
bool enableEncryption = Program.Option("Encryption").Value == "On";
bool importExternal = Program.Option("ImportExternal").Value == "On";
if (importExternal) {
  Program.Option("Encryption").Value = "";
  enableEncryption = false;
}

var MqttIsConnected = false;
MqttClient.Reset();
Program.Emit("MQTT.Status", "configure");

// key used for encryption
byte[] key = Encoding.UTF8.GetBytes(Program.SystemId);

string subscribeTopic = clientid + "/#";
if (enableEncryption) {
  subscribeTopic = encryptTopic(clientid, key) + "/#";
}
if (importExternal) {
  subscribeTopic = "#";
} else {
  // export MQTT-published modules
  Program.AddFeature("", "", "MQTT.SensorPublish", "Publish events emitted by this module", "checkbox");
}

Action&lt;string, string, byte[]&gt; publishBytes = (string cid, string topic, byte[] payload) =&gt; {
  if (enableEncryption) {
    topic = encryptTopic(cid, key) + "/" + encryptTopic(topic, key);
    payload = encryptionFilter(payload, key);
  } else {
    topic = cid + "/" + topic;
  }
  MqttClient.Publish(topic, payload);
};

Action&lt;string, string, string&gt; publish = (string cid, string topic, string message) =&gt; {
  publishBytes(cid, topic, Encoding.UTF8.GetBytes(message));
};

Action&lt;string&gt; apiHandle = (string cid) =&gt; {
  Api.Handle("MQTT:" + cid, ( args ) =&gt; {
    var request = Api.Parse(args);
    var domain = request.Domain;
    var address = request.Address;
    string command = $"{request.Command}/{request.OptionsString}";
    try
    {
      int mqttend = domain.IndexOf(".");
      int mqttdel = domain.IndexOf(":");
      var mqttdest  = domain.Substring(mqttdel + 1, mqttend - mqttdel - 1);
      domain = domain.Substring(mqttend + 1);

      var cmd = new MigInterfaceCommand(domain + "/" + address + "/" + command, request.Data);
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(cmd));
      string payload = Encoding.UTF8.GetString(bytes);
      publish(clientid, "MQTT.Listeners/" + mqttdest + "/command", payload);

      return new ResponseText("OK");
    } catch (Exception e) {
      Program.Notify($"ERROR #2: {e.Message} {OptionButtons}");
      MqttIsConnected = false;
    }
    return new ResponseText("ERROR");
  });
};

MqttClient.Subscribe(subscribeTopic, (mtopic, bytespayload) =&gt; {
  var parts = mtopic.Split('/');
  var cid = parts[0];
  if (parts.Length == 2) { // encrypted topic
    cid = decryptTopic(cid, key);
    mtopic = decryptTopic(parts[1], key);
    mtopic = cid + "/" + mtopic;
    parts = mtopic.Split('/');
    bytespayload = encryptionFilter(bytespayload, key);
  }
  if (parts.Length == 4)
  {
    try
    {
      var domain = parts[1];
      var address = parts[2];
      var type = parts[3];

      // convert binary message to string
      string mpayload = Encoding.UTF8.GetString(bytespayload);

      var module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();

      switch (type)
      {
        case "command":
        if (domain == "MQTT.Listeners" &amp;&amp; address == clientid)
        {
          var cmdobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
          var targetmodule = Modules.InDomain(cmdobj.Domain.ToString()).WithAddress(cmdobj.Address.ToString());
          if (targetmodule.Get().Instance != null)
          {
            string command = cmdobj.Command.ToString();
            switch (command)
            {
              case "Module.Describe":
              var modinstance = targetmodule.Get().Instance;
              publish(clientid, modinstance.Domain + "/" + modinstance.Address + "/description", Service.Utility.Module2Json(modinstance, false));
              break;
              default:
              var m = targetmodule.Get().Instance;
              var apiCommand = m.Domain + "/" + m.Address + "/" + command;
              var result = Api.Call(apiCommand, cmdobj.Data);
              try {
                result = (byte[])result;
                publishBytes(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", (byte[])result);
              } catch (Exception e) {
                publish(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
              }
              break;
            }
          }
        }
        break;

        case "request":
        var reqobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
        try {
          var result = Api.Call(reqobj.Request.ToString(), reqobj.Data);
          // send response with result
          //if (result != "null") {
            try {
              result = (byte[])result;
              publishBytes(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", (byte[])result);
            } catch (Exception e) {
              publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
            }
          //} else {
          //  publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
          //}
        } catch (Exception e) {
          Program.Notify(e.Message);
        }
        break;

        case "description":
        if (cid != clientid &amp;&amp; module.Instance != null)
        {
          var modobj = JsonConvert.DeserializeObject&lt;Module&gt;(mpayload);
          module.Instance.Name = modobj.Name;
          module.Instance.Description = modobj.Description;
          module.Instance.DeviceType = modobj.DeviceType;
          var parentid = module.Parameter("VirtualModule.ParentId").Value;
          module.Instance.Properties = modobj.Properties;
          module.Parameter("VirtualModule.ParentId").Value = parentid;
          module.Parameter("MQTT.SourceNode").Value = cid;
          //Program.Notify("Imported remote module " + module.Instance.Domain + " " + module.Instance.Address);
        }
        break;

        case "event":
        if (cid != clientid &amp;&amp; importExternal)
        {
          var property = JsonConvert.DeserializeObject&lt;ModuleParameter&gt;(mpayload);
          if (module.Instance == null)
          {
            Program.AddModule("MQTT:" + cid + "." + domain, address, "Sensor", "");
            module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();
            apiHandle(cid);
          }
          else if (!module.HasParameter("MQTT.SourceNode"))
          {
            publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + domain + "', 'Address' : '" + address + "', 'Command' : 'Module.Describe' }");
          }
          module.Emit(property.Name, property.Value);
        }
        break;
      }
    } catch (Exception e) {
      Program.Notify($"ERROR #1: {e.Message} {OptionButtons}");
      MqttIsConnected = false;
    }
  }
});

When.ModuleParameterChanged( (module, property) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; property.Name.StartsWith("ConfigureOptions.")) {
    if (Program.IsRunning) Program.Restart();
    return true;
  }
  if (!importExternal &amp;&amp; module.HasFeature("MQTT.SensorPublish") &amp;&amp; !module.Instance.Domain.StartsWith("MQTT:"))
  {
    try{
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(property));
      publishBytes(clientid, module.Instance.Domain + "/" + module.Instance.Address + "/event", bytes);
    } catch  (Exception e){
      //Program.Notify($"ERROR: {e.Message} {OptionButtons}");
      MqttIsConnected = false;
    }
  }
  // returning true, will route event to other listeners
  return true;
});

// Validate configuration

if (String.IsNullOrEmpty(clientid))
{
  clientid = Program.Option("ClientId").Value = Program.SystemId;
}
if (String.IsNullOrEmpty(server))
{
  Program.Notify($"MQTT endpoint is not configured. {OptionButtons}");
  Pause(5);
  return;
}

Action&lt;string&gt; importModules = (string serverAddress) =&gt; {
  try {
    var domain = "HomeAutomation.HomeGenie";
    var data = Net
      .WebService($"http://{serverAddress}/api/{domain}/Config/Modules.List")
      .GetData();
    List&lt;Module&gt; modules = JsonConvert.DeserializeObject&lt;List&lt;Module&gt;&gt;(data.ToString());
    var mini = modules.Find(md =&gt; md.Domain == domain &amp;&amp; (md.Address == "mini" || md.Address == "system"));
    var systemInfo = mini.Properties.Find(p =&gt; p.Name == "System.Info");
    dynamic info = JsonConvert.DeserializeObject(systemInfo.Value);
    string cid = info.Id;
    apiHandle(cid);
    foreach (var m in modules) {
      string type = m.DeviceType.ToString();
      if (type == "Program") continue;
      Program.AddModule("MQTT:" + cid + "." + m.Domain, m.Address, type, "");
      publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + m.Domain + "', 'Address' : '" + m.Address + "', 'Command' : 'Module.Describe' }");
    }
  } catch (Exception e) {
    Program.Notify($"{e.Message}");
  }
};
if (!importExternal)
{
  apiHandle("");
}

while (Program.IsRunning) {

  // Connect to MQTT

  if (!MqttIsConnected) {
    MqttIsConnected = true;
    Program.Notify("Connecting to '" + server + ":" + port + "' ...");
    Program.Emit("MQTT.Status", "connecting");
    try
    {
      if (username != "")
      {
        MqttClient.WithCredentials(username, password);
      }

      MqttClient
        .Service(server)
        .UsingWebSockets(useWebSockets)
        .WithTls(useTls)
        .Connect(port, Guid.NewGuid().ToString(), (connected)=&gt; {
          MqttIsConnected = connected;
          if (connected) {
              Program.Notify("Connected!");
              Program.Emit("MQTT.Status", "connected");
              if (importExternal) 
              {
                importModules(server);
              }
          } else {
              Program.Notify("Disconnected!");
              Program.Emit("MQTT.Status", "disconnected");
          }
        });
    }
    catch (Exception e)
    {
      Program.Notify($"{e.Message} {OptionButtons}");
      Pause(5);
      return;
    }
  }

  Pause(30);

}
</ScriptSource>
    <ScriptContext>const string OptionButtons = "[program_configure,program_disable]";
static string encryptionKey = "";

static string encryptTopic(string topic, byte[] clientKey) {
    byte[] t = Encoding.UTF8.GetBytes(topic);
    t = encryptionFilter(t, clientKey);

    string encryptedTopic = Convert.ToBase64String(t);
    encryptedTopic = encryptedTopic.Replace("/", "%");
    encryptedTopic = encryptedTopic.Replace("+", "&amp;");

    return encryptedTopic;
}

static string decryptTopic(string topic, byte[] clientKey) {
    topic = topic.Replace("%", "/");
    topic = topic.Replace("&amp;", "+");
    byte[] encryptedTopic = Convert.FromBase64String(topic);
    return Encoding.UTF8.GetString(encryptionFilter(encryptedTopic, clientKey));
}

static byte[] encryptionFilter(byte[] payload, byte[] clientKey) {
    if (!String.IsNullOrEmpty(encryptionKey)) {
        byte[] output = new byte[256];
        byte[] k = Convert.FromBase64String(encryptionKey);
        k = andFilter(k, clientKey);
        payload = xorFilter(payload, k);
    }
    return payload;
}

static byte[] xorFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k ^ i);
            payload[c] = o;
        }
    }
    return payload;
}

static byte[] andFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k &amp; i);
            payload[c] = o;
        }
    }
    return payload;
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>mqtt-network</Id>
      <Version>1.0.7</Version>
      <Required>true</Required>
      <Checksum>0CA2694034713BC867D3695C77729011</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>77</Address>
    <Name>MQTT Network</Name>
    <Description>Connect to an MQTT broker to use HomeGenie Panel app from anywhere via Internet or to interconnect HomeGenie devices on the same MQTT network.</Description>
    <Group>Interconnections</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes />
        <Property>MQTT.SensorPublish</Property>
        <Description>Publish events emitted by this module</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>true</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// list the program as custom weather widget
Program.UseWidget( "homegenie/environment/weather" )
  // set input fields parameters
  // &lt;field_name&gt;, &lt;default_value&gt;, &lt;description&gt;
  .AddOption("Location", "London, UK", "City name", "wunderground.city")
  .AddOption("Language", "EN", "Language", "text")
  .AddOption("ApiKey", "?", "OpenWeatherMap API key (APPID)", "text")
  .AddOption("UpdateInterval", "30", "Update interval (minutes)", "slider:15:1440:15:15");

// initialize widget program parameters
Program.Parameter("Astronomy.Sunset").Value = "";
Program.Parameter("Astronomy.Sunrise").Value = "";
Program.Parameter("Conditions.City").Value = "";
Program.Parameter("Conditions.Temperature").Value = "";
Program.Parameter("Conditions.DisplayLocation").Value = "";
Program.Parameter("Conditions.IconType").Value = "";
Program.Parameter("Conditions.Description").Value = "";

Program.Parameter("EventsLogger.EnableLogging").Value = "On";
Program.Run();
</ScriptSetup>
    <ScriptSource>Action&lt;dynamic&gt; UpdateWeatherParameters = (data) =&gt; {
  Program
    .Emit("Conditions.City", data.city)
    .Emit("Conditions.DisplayLocation", data.city)
    .Emit("Conditions.Country", data.country)
    .Emit("Conditions.Description", data.weather_description)
    .Emit("Conditions.IconType", data.weather_icon)
    .Emit("Conditions.Status", data.weather_status) // eg. cloudy, sunny, etc..
    .Emit("Conditions.LastUpdated", data.update_dt)
    // Add values to standard Sensor.* parameters
    .Emit("Sensor.Temperature", data.temperature)
    .Emit("Sensor.Temperature.Unit", "Celsius")
    .Emit("Sensor.Pressure", data.pressure)
    .Emit("Sensor.Pressure.Unit", "Mb")
    .Emit("Sensor.Wind.Speed", data.wind_speed)
    .Emit("Sensor.Wind.Speed.Unit", "Kph")
    .Emit("Sensor.Wind.Direction", data.wind_direction)
    .Emit("Sensor.Precipitation.Rain", data.rain_1h_mm)
    .Emit("Sensor.Precipitation.Rain.Unit", "1h")
    .Emit("Sensor.Precipitation.Snow", data.snow_1h_mm)
    .Emit("Sensor.Precipitation.Snow.Unit", "1h");
  // TODO: Program.Parameter("Sensor.UV").Value = "...";
};
Action&lt;int,dynamic&gt; UpdateForecastParameters = (day, data) =&gt; {
  Program
    .Emit("Conditions.Forecast." + day + ".Description", data.weather_description)
    .Emit("Conditions.Forecast." + day + ".Year", data.dt.Year.ToString("YYYY"))
    .Emit("Conditions.Forecast." + day + ".Month", data.dt.ToString("MMM"))
    .Emit("Conditions.Forecast." + day + ".Day", data.dt.ToString("dd"))
    .Emit("Conditions.Forecast." + day + ".Weekday", data.dt.ToString("dddd"))
    .Emit("Conditions.Forecast." + day + ".IconType", data.weather_icon)
    .Emit("Conditions.Forecast." + day + ".Temperature", data.temperature)
    .Emit("Conditions.Forecast." + day + ".Temperature.Min", data.temperature_min)
    .Emit("Conditions.Forecast." + day + ".Temperature.Max", data.temperature_max);
};
Func&lt;string,string&gt; GetWeatherIcon = (type) =&gt; {
  var icon = type;
  switch(type)
  {
    case "clear": // 	clear sky
      icon = "01d";
      break;
    case "partlycloudy": // 	few clouds
      icon = "02d";
      break;
    case "scatteredclouds": // scattered clouds
      icon = "03d";
      break;
    case "cloudy": // broken clouds (?)
      icon = "04d";
      break;
    case "showerrain": // 	shower rain
      icon = "09d";
      break;
    case "rain": // rain
      icon = "10d";
      break;
    case "thunderstorms": // thunderstorms
      icon = "11d";
      break;
    case "snow": // snow
      icon = "13d";
      break;
    case "hazy": // mist
      icon = "50d";
      break;
    // Night icons
    case "clear_night": // 	clear sky
      icon = "01n";
      break;
    case "partlycloudy_night": // 	few clouds
      icon = "02n";
      break;
    case "scatteredclouds_night": // scattered clouds
      icon = "03n";
      break;
    case "cloudy_night": // broken clouds (?)
      icon = "04n";
      break;
    case "showerrain_night": // 	shower rain
      icon = "09n";
      break;
    case "rain_night": // rain
      icon = "10n";
      break;
    case "thunderstorms_night": // thunderstorms
      icon = "11n";
      break;
    case "snow_night": // snow
      icon = "13n";
      break;
    case "hazy_night": // mist
      icon = "50n";
      break;
  }
  return icon;
};
Func&lt;dynamic, dynamic&gt; CollectWeatherData = (weatherData) =&gt; {
  dynamic data = new ExpandoObject();
  data.dt = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.dt);
  data.update_dt = data.dt.ToLongDateString() + " " + TimeZoneInfo.ConvertTime(data.dt, TimeZoneInfo.Local).ToLongTimeString();
  data.temperature = weatherData.main.temp.ToString();
  data.temperature_min = weatherData.main.temp_min.ToString();
  data.temperature_max = weatherData.main.temp_max.ToString();
  data.pressure = weatherData.main.pressure.ToString();
  var rain_1h_mm = "0";
  var rain_3h_mm = "0";
  if (weatherData.rain != null) {
    if (weatherData.rain["1h"] != null)
      rain_1h_mm = weatherData.rain["1h"].ToString();
    if (weatherData.rain["3h"] != null)
      rain_3h_mm = weatherData.rain["3h"].ToString();
  }
  data.rain_1h_mm = rain_1h_mm;
  var snow_1h_mm = "0";
  var snow_3h_mm = "0";
  if (weatherData.snow != null) {
    if (weatherData.snow["1h"] != null)
      snow_1h_mm = weatherData.snow["1h"].ToString();
    if (weatherData.snow["3h"] != null)
      snow_3h_mm = weatherData.snow["3h"].ToString();
  }
  data.snow_1h_mm = snow_1h_mm;
  data.wind_speed = weatherData.wind.speed.ToString();
  data.wind_direction = "";
  if (weatherData.wind.deg != null)
  	data.wind_direction = weatherData.wind.deg.ToString();
  data.weather_status = weatherData.weather[0].main.ToString();
  data.weather_description = weatherData.weather[0].description.ToString();
  data.weather_icon = GetWeatherIcon(weatherData.weather[0].icon.ToString());
  // city and country fields are not present in forecast data
  if (weatherData.name != null)
  	data.city = weatherData.name.ToString();
  if (weatherData.sys != null &amp;&amp; weatherData.sys.country != null)
  	data.country = weatherData.sys.country.ToString();
  return data;
};

bool reconfigureRequired = false;
When.ModuleParameterChanged((module, parameter) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
    reconfigureRequired = true;
  }
  return true;
});

while (Program.IsRunning)
{
  string location = Program.Option("Location").Value;
  string language = Program.Option("Language").Value;
  string apikey = Program.Option("ApiKey").Value.Trim();

  if (!apikey.Contains("?") &amp;&amp; apikey.Length &gt; 0)
  {
    try
    {
      string webserviceurl = "https://api.openweathermap.org/data/2.5/weather?q=" + location + "&amp;lang=" + language + "&amp;units=metric&amp;appid=" + apikey;
      var weatherData = Net.WebService(webserviceurl).GetData();

      var sunset = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunset);
      var sunrise = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunrise);

      Program.Emit("Astronomy.Sunset", TimeZoneInfo.ConvertTime(sunset, TimeZoneInfo.Local).ToShortTimeString());
      Program.Emit("Astronomy.Sunrise", TimeZoneInfo.ConvertTime(sunrise, TimeZoneInfo.Local).ToShortTimeString());

      var data = CollectWeatherData(weatherData);
      UpdateWeatherParameters(data);

      // get forecast data
	  webserviceurl = "https://api.openweathermap.org/data/2.5/forecast?q=" + location + "&amp;lang="+language+"&amp;units=metric&amp;appid=" + apikey;
      var forecast = Net.WebService(webserviceurl).GetData();

      var forecastDay = 1;
      var nextDay = DateTime.UtcNow.AddDays(1); nextDay = nextDay.Date + new TimeSpan(12, 0, 0);
      foreach(var fc in forecast.list)
      {
        var forecastTime = Utility.JavaTimeStampToDateTime(1000D*(int)fc.dt);
        if (forecastTime.Equals(nextDay)) {
          // collect forecast data for current forecastDay

          var forecastData = CollectWeatherData(fc);
          UpdateForecastParameters(forecastDay, forecastData);

          nextDay = nextDay.AddDays(1);
          forecastDay++;
        }
        // process up to 3 days
        if (forecastDay &gt; 3) break;
      }
      //Program.Emit("Program.UiRefresh", "Data Updated");

    }
    catch (Exception e)
    {

      Program.Notify("ERROR: unable to get data from service. " + e.Message);
      Console.WriteLine( e.Message );
      Pause(10);

    }
  }
  //
  var delayMins = Program.Option("UpdateInterval").DecimalValue;
  if (delayMins &lt; 1) delayMins = 1;
  double pauseBeforeNextUpdate = delayMins*60; // seconds
  while (pauseBeforeNextUpdate-- &gt; 0 &amp;&amp; !reconfigureRequired) {
	  Pause(1);
  }
  reconfigureRequired = false;
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>openweathermap</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>4B044176D2110D4A1DC97E6B00B5442C</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>34</Address>
    <Name>OpenWeatherMap</Name>
    <Description>Weather and forecast information from Open Weather Map service.
To activate this widget enter a valid API key.
Follow instructions at https://openweathermap.org/appid to get a free API key.
</Description>
    <Group>Weather and Environment</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// This method is used to register this program as a Chart provider
Program.Implements(
    "@Statistics:Provider",
    apiUrl,
     // the following param's value can be:
     // --&gt; "select_module", "select_property" or "select_none"
    new {
        mode = "select_none",
        legend = true,
        icon = "pie_chart"
    }
).Run();
</ScriptSetup>
    <ScriptSource>// This API method will be called by the chart component
// to get the configuration of the chart to generate
Api.Handle(apiUrl, (args) =&gt; {
    return new {
        // API url to call to get updated chart data from this program
        dataApi = dataApiUrl,
        // Chart configuration
        scale = "linear",
        type = "pie",
        title = "kW/h today",
        labels = new string[] {
            "🍗 Oven",
            "🔥 Boiler",
            "🥵 Heater",
            "🍹 Living Room",
            "📖 Study"
        },
        colors = new string[] {
            "rgb(197,137,64)",
            "rgb(229,186,115)",
            "rgb(250,234,177)",
            "rgb(255,247,218)",
            "rgb(255,253,244)"
        }
    };
});

// API method implementation
Api.Handle(dataApiUrl, (args) =&gt; {
    // Just a demo, return fixed data
    return new double[] {
        500, 400, 300, 200, 100
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/ExamplePieChart";
const string dataApiUrl = "DataProcessing.Statistics/MyStat";

</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>pie-chart-stats-example</Id>
      <Version>1.0.1</Version>
      <Required>false</Required>
      <Checksum>8B4B14BE32EBB0547A142489DF72CF43</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>572</Address>
    <Name>Pie Chart Stats example</Name>
    <Description>Example chart provider that renders as a pie chart with static data.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.Enable", "Enable remote control", "checkbox")
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.IRCode", "Toggle button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerUpCode", "ButtonUp", "1. Bright button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerDownCode", "ButtonDown", "2. Dim button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerInterval", "10", "4. Dimming step %", "slider:5:50:5")
  .Run();
</ScriptSetup>
    <ScriptSource>var dimmerInterval = Program.Option("DimmerInterval");
var dimmerUp = Program.Option("DimmerUpCode");
var dimmerDown = Program.Option("DimmerDownCode");
var irControlModules = Modules.WithFeature("HomeGenie.RemoteControl.Enable");

When.ModuleParameterChanged((module, parameter) =&gt; {
  if(parameter.Name == "Receiver.RawData" )
  {
    var irData = parameter;
    var lastButton = module.Parameter("IrController.LastButton");
    var lastIdle = module.Parameter("IrController.LastIdle");
    var dimStep = dimmerInterval.DecimalValue / 100D;

    if (irData.Value != "")
    {
      if (lastButton.Value != "" &amp;&amp; lastIdle.IdleTime &gt; 0.25 &amp;&amp; (irData.Value == dimmerUp.Value || irData.Value == dimmerDown.Value))
      {
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == lastButton.Value)
          {
            var level = m.Level;
            if (irData.Value == dimmerUp.Value)
            {
              level += dimStep;
              m.Level = (level &gt;= 1 ? 1 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Bright (" + m.Level + ")");
            }
            else if (irData.Value == dimmerDown.Value)
            {
              level -= dimStep;
              m.Level = (level &lt;= 0.05 ? 0.05 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Dim (" + m.Level + ")");
            }
            lastIdle.Value = "0";
          }
          return false; // do not break, continue iterating...
        });
      }
      else
      {
        if (lastIdle.IdleTime &gt; 0.5)
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == irData.Value)
          {
            lastButton.Value = irData.Value;
            lastIdle.Value = "1";
            m.Toggle();
            Program.Notify(m.Instance.Name + "&lt;br&gt;toggled.");
          }
          return false; // do not break, continue iterating...
        });
      }
    }
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>remote-control</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>F55B4203889EEC49B831E1F1AF765BCD</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>505</Address>
    <Name>Remote Control</Name>
    <Description>Toggle and dim the device using a remote controller (IR or RF).</Description>
    <Group>Lights</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.Enable</Property>
        <Description>Enable remote control</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>capture:Receiver.RawData</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.IRCode</Property>
        <Description>Toggle button (enter code)</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.UseWidget("homegenie/generic/sensor");
//Program.Run();</ScriptSetup>
    <ScriptSource>#using NWaves.Signals.Builders
// For NWaves DSP library documentation see:
// https://github.com/ar1st0crat/NWaves?tab=readme-ov-file

DiscreteSignal sinusoid = 
    new SineBuilder()
        .SetParameter("frequency", 200/*Hz*/)
        .SetParameter("phase", Math.PI)
        .OfLength(50)
        .SampledAt(5000/*Hz*/)
        .Build();

var samples = new List&lt;float&gt;(sinusoid.Samples);
while (Program.IsRunning)
{
    foreach (var s in samples)
    {
        double v = (s * .5) + .5;
        Program.Emit("Sensor.SineWave", v);
        // synchronize level of a module with sinewave value [0.0 .. 1.0]
        /*
        Modules
            .WithName("My module name")
            .Level = v;
        */
        Pause(.2);
    }
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.2</PackageVersion>
      <Id>sine-wave-signal</Id>
      <Version>1.0.1</Version>
      <Required>false</Required>
      <Checksum>F1B6DB2FD949FE29E31F0183ACFE5B3B</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>900</Address>
    <Name>SineWave Signal</Name>
    <Description>Example</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>false</IsEnabled>
  </ProgramBlock>
</ArrayOfProgramBlock>