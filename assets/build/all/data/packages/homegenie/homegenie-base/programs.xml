<?xml version="1.0" encoding="utf-8"?>
<ArrayOfProgramBlock xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <ProgramBlock>
    <ScriptSetup>Program.Run();
</ScriptSetup>
    <ScriptSource>// ===================================================================
// MULTI-STORE CHAT HISTORY SERVICE
// ===================================================================

string dataFolder = Data.GetFolder();

Api.Handle("System.Utility/ChatHistory", (args) =&gt; {
    var request = Api.Parse(args);
    
    dynamic data = (request.Data is string) ? JObject.Parse((string)request.Data) : JObject.FromObject(request.Data);

    string storeId = data?.StoreId?.ToString() ?? "default";
    var currentHistory = HistoryStore.GetStore(dataFolder, storeId);

    switch(request.Command) {

        case "Get":

            return currentHistory;

        case "Add":

            var msg = JsonConvert.DeserializeObject&lt;ChatMessage&gt;(data.Message.ToString());
            if (msg != null) {
                currentHistory.Add(msg);
                HistoryStore.Save(dataFolder, storeId);
            }
            return new { Count = currentHistory.Count };

        case "PopLast":

            if (currentHistory.Count &gt; 0) {
                currentHistory.RemoveAt(currentHistory.Count - 1);
                HistoryStore.Save(dataFolder, storeId);
            }
            return new { Count = currentHistory.Count };

        case "Clear":

            currentHistory.Clear();
            HistoryStore.Save(dataFolder, storeId);
            return new { Status = "Cleared" };

        default:
            return new ResponseStatus(Status.Error, $"Unknown command: {request.Command}");
    }
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>
// --- POJO MODELS ---

public class MessagePart
{
    [JsonProperty("text")]
    public string Text { get; set; }
}

public class ChatMessage
{
    [JsonProperty("role")]
    public string Role { get; set; }
    [JsonProperty("parts")]
    public List&lt;MessagePart&gt; Parts { get; set; } = new List&lt;MessagePart&gt;();

    public static ChatMessage Create(string role, string text)
    {
        return new ChatMessage { 
            Role = role, 
            Parts = new List&lt;MessagePart&gt; { new MessagePart { Text = text } } 
        };
    }
}

// --- MULTI-STORE PERSISTENCE ---

public static class HistoryStore
{
    // Dizionario che tiene in memoria le diverse cronologie caricate
    public static Dictionary&lt;string, List&lt;ChatMessage&gt;&gt; Stores { get; set; } = new Dictionary&lt;string, List&lt;ChatMessage&gt;&gt;();

    private static string GetFilePath(string folder, string storeId)
    {
        return Path.Combine(folder, $"history_{storeId}.json");
    }

    public static List&lt;ChatMessage&gt; GetStore(string folder, string storeId)
    {
        if (!Stores.ContainsKey(storeId))
        {
            Load(folder, storeId);
        }
        return Stores[storeId];
    }

    public static bool Load(string folder, string storeId)
    {
        try {
            string path = GetFilePath(folder, storeId);
            if (File.Exists(path)) {
                var list = JsonConvert.DeserializeObject&lt;List&lt;ChatMessage&gt;&gt;(File.ReadAllText(path));
                Stores[storeId] = list ?? new List&lt;ChatMessage&gt;();
                return true;
            }
        } catch { }
        Stores[storeId] = new List&lt;ChatMessage&gt;();
        return false;
    }

    public static bool Save(string folder, string storeId)
    {
        try {
            if (!Stores.ContainsKey(storeId)) return false;
            string path = GetFilePath(folder, storeId);
            File.WriteAllText(path, JsonConvert.SerializeObject(Stores[storeId], Formatting.Indented));
            return true;
        } catch { return false; }
    }
}
</ScriptContext>
    <ScriptErrors>[]</ScriptErrors>
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>chat-history-service</Id>
      <Version>1.0.0</Version>
      <Required>true</Required>
      <Checksum>3257E9D93488EB5073035391A0AFD9F1</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>577</Address>
    <Name>Chat History Service</Name>
    <Description>Centralized HomeGenie service for managing and persisting AI chat logs. Through a unified API (System.Utility/ChatHistory), it provides cloud and local LLMs with a shared context, automated JSON storage, and real-time history management.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>var dataFolder = Data.GetFolder(PresetsFolder);
Data.AddToSystemBackup(dataFolder);
Program.Run();
</ScriptSetup>
    <ScriptSource>var dataFolder = Data.GetFolder(PresetsFolder);

Api.Handle($"{apiBaseUrl}List", (args) =&gt; {
    var files = Directory.GetFiles(dataFolder);
    return files.Select(f =&gt; Path.GetFileNameWithoutExtension(f));
});
Api.Handle($"{apiBaseUrl}Add/", (args) =&gt; {
    var command = Api.Parse(args);
    if (command.Data != null) {
        var configuration = System.Text.Encoding.Default.GetString(command.Data as byte[]);
        var presetName = command.GetOption(0);
        if (String.IsNullOrEmpty(presetName)) {
            presetName = "default";
        }
        var dataFile = Path.Combine(dataFolder, presetName + ".json");
        File.WriteAllText(dataFile, configuration);
    }
    return new ResponseStatus(Status.Ok);
});
Api.Handle($"{apiBaseUrl}Get/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        presetName = "default";
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    var config = "{config: null, preferences: null}";
    if (File.Exists(dataFile)) config = File.ReadAllText(dataFile);
    return config;
});
Api.Handle($"{apiBaseUrl}Delete/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        return new ResponseStatus(Status.Error);
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    File.Delete(dataFile);
    return new ResponseStatus(Status.Ok);
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string PresetsFolder = "client-presets";
const string apiBaseUrl = "HomeAutomation.HomeGenie/Config/Client.Presets";
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>client-configs</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>0BE01D06C8342351AC31E74439BA6022</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>111</Address>
    <Name>Client configuration</Name>
    <Description>Implements API for managing client's configuration profiles that are used to store client's UI and dashboards settings.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements("@Statistics:Provider", ApiUrl, new {
    icon = "legend_toggle"
}).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(ApiUrl, (args) =&gt; {
    return new {
        dataApi = DataApiUrl,
        scale = "time",
        filters = new string[] {
            "SimpleAverage",
            "MovingAverage",
            "SavitzkyGolay"
        }
    };
});


var ParseArgs = new Func&lt;object, MigInterfaceCommand&gt;((args) =&gt; {
    string storageDomain = "";
    string requestString = args is string ? args.ToString() : (args as MigInterfaceCommand).OriginalRequest;
    int storageIndex = requestString.IndexOf("@");
    if (storageIndex &gt; 0) {
        storageDomain = requestString.Substring(storageIndex + 1).Split("/")[0];
        var delimiter = $"@{storageDomain}/";
        requestString = requestString.Substring(requestString.IndexOf(delimiter) + delimiter.Length);
    }
    return new MigInterfaceCommand(requestString, storageDomain);
});


Api.Handle($"{DataApiUrl}/TimeRange", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        if (string.IsNullOrEmpty(storageDomain))
        {
            // default data storage endpoint
            storageDomain = "HomeAutomation.HomeGenie/Config/Modules.StatisticsGet";
        }
        return Api.Call($"{storageDomain}/{module.Instance.Domain}/{module.Instance.Address}/{parameter.Name}/TimeRange");
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/RawData", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        try
        {
            var stats = GetRawData(storageDomain, module.Instance, parameter, startTime, endTime);
            stats.Reverse();
            return stats;
        }
        catch (Exception e)
        {
            return e;
        }
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});


Api.Handle($"{DataApiUrl}/SimpleAverage", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));
        try
        {
            var stats = ApplySimpleAverageFilter(storageDomain, module.Instance, parameter, startTime, endTime, chartWidth);
            stats.Reverse();
            return stats;
        }
        catch (Exception e)
        {
            return e;
        }
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/MovingAverage", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new MovingAverageFilter(windowSize);
        var stats = ApplyFilter(storageDomain, filter, module.Instance, parameter, startTime, endTime, chartWidth);
        stats.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/SavitzkyGolay", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new SavitzkyGolayFilter(windowSize);
        var stats = ApplyFilter(storageDomain, filter, module.Instance, parameter, startTime, endTime, chartWidth);
        stats.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>#using StatValue = HomeGenie.Data.ValueStatistics.StatValue

const string ApiUrl = "Statistics.Providers/DataMonitor";
const string DataApiUrl = "DataProcessing.Filters/Series";

const int windowSize = 9;

List&lt;StatValue&gt; GetRawData(string storageDomain, Module module, ModuleParameter parameter, double startTime, double endTime)
{
    startTime = (long)startTime;
    endTime = (long)endTime;

    var stats = new ValueStatistics();

    if (String.IsNullOrEmpty(storageDomain)) {
        // Read from runtime Statistics History
        stats.History = new TsList&lt;StatValue&gt;(
                parameter.Statistics.History
                    .Where(sv =&gt; sv != null &amp;&amp; sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
                    .ToList()
            );
    } else {
        // Read from persistent database provider (such as Event Logger or remote cloud service)
        var results = (List&lt;LoggerEvent&gt;)Api.Call($"{storageDomain}/{module.Domain}/{module.Address}/{parameter.Name}/{startTime}/{endTime}");
        stats.History = new TsList&lt;StatValue&gt;(results
            .Select(logEvent =&gt; {
                string ev = logEvent.Value?.ToString().Replace(",", ".") ?? string.Empty;
                double value;
                if (!double.TryParse(ev, NumberStyles.Any, CultureInfo.InvariantCulture, out value))
                {
                    value = double.NaN;
                }
                return new StatValue(value, DateTimeOffset.FromUnixTimeMilliseconds(logEvent.UnixTimestamp).UtcDateTime);
            }).Where(sv =&gt; !double.IsNaN(sv.Value)).ToList());
    }

    var data = stats.History;
    data.Reverse();
    return data;
}

List&lt;StatValue&gt; ApplySimpleAverageFilter(string storageDomain, Module module, ModuleParameter parameter, double startTime, double endTime, double chartWidth)
{
    var data = GetRawData(storageDomain, module, parameter, startTime, endTime);
    // Process time series
    if (startTime &gt; 0 &amp;&amp; data.Count &gt; 0 &amp;&amp; chartWidth &lt; data.Count)
    {
        var cts = data.First().UnixTimestamp;
        var cte = data.Last().UnixTimestamp;
        var stepMs = ((endTime - startTime) / chartWidth) * ((cte - cts) / (endTime - startTime));
        if (stepMs &lt; 1000) stepMs = 1000;
        var resampledList = new List&lt;StatValue&gt;();
        cts -= (cts % stepMs);
        cts -= stepMs;
        var sum = 0D;
        var count = 0;
        int i = 0;
        var itemTimestamp = DateTime.UtcNow;
        while (i &lt; data.Count)
        {
            var item = data[i];
            if (item.UnixTimestamp &gt;= cts)
            {
                var resampled = new StatValue(
                    sum / count,
                    itemTimestamp
                );
                resampledList.Add(resampled);
                sum =0; count = 0;
                cts += stepMs;
            }
            sum += item.Value;
            itemTimestamp = item.Timestamp;
            count++;
            i++;
        }
        data = new TsList&lt;StatValue&gt;(resampledList);
    }
    return data;
}

List&lt;StatValue&gt; ApplyFilter(string storageDomain, NWaves.Filters.Base.IFilter filter, Module module, ModuleParameter parameter, double startTime, double endTime, double chartWidth) {
    var timeSpan = (endTime - startTime);
    var timeSpanMin = (timeSpan / 2);
    var data = ApplySimpleAverageFilter(storageDomain, module, parameter, startTime - timeSpanMin, endTime + timeSpanMin, chartWidth);

    // Process time series
    var samples = data
        .Select(sv =&gt; (float)sv.Value)
        .ToArray();
    var signal = new DiscreteSignal(50/*Hz sampling rate*/, samples);
    var smoothedSignal = filter.ApplyTo(signal);
    var lst = new List&lt;StatValue&gt;();
    int boundsGap = (windowSize - 1) / 2;
    for (int c = 0; c &lt; data.Count - boundsGap; c++)
    {
        var sv = data[c];
        if (sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
        {
            lst.Add(new StatValue(smoothedSignal[c + boundsGap], sv.Timestamp));
        }
    }

    data = new TsList&lt;StatValue&gt;(lst);
    return data;
}
</ScriptContext>
    <ScriptErrors>[]</ScriptErrors>
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>stats-data-monitor</Id>
      <Version>1.0.5</Version>
      <Required>true</Required>
      <Checksum>F7945A866C7285570C60C48B592CC37F</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>570</Address>
    <Name>Data Monitor</Name>
    <Description>Centralized analysis service for historical module statistics. It enables dynamic retrieval of time-series data with built-in signal processing filters (Simple Average, Moving Average, Savitzky-Golay) to provide clean, smoothed data for charts and system monitoring.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Run();</ScriptSetup>
    <ScriptSource>// Initialize the central download manager
var downloadManager = new DownloadManager();

// Ensure resources are released when the program stops
When.ProgramStopping(() =&gt; {
    downloadManager.Dispose();
    return true;
});

// Define the API endpoint for DownloadManager interactions
Api.Handle("System.Utility/DownloadManager", (args) =&gt; {

    var request = Api.Parse(args);
    dynamic data = null;

    // Attempt to deserialize input data (handles both string and byte arrays)
    try
    {
        string jsonString = request.Data is string ? request.Data.ToString() : System.Text.Encoding.UTF8.GetString((byte[])request.Data);
        data = JsonConvert.DeserializeObject&lt;dynamic&gt;(jsonString);
    }
    catch (Exception ex)
    {
        data = request.Data.ToString();
    }

    object responseData = null;
    bool success = true;

    try
    {
        // Handle different operations based on the 'Command' parameter
        switch(request.Command) {

            case "Enqueue":
                // Validate inputs and add a new download to the queue
                if (data == null) throw new ArgumentException("Enqueue command requires a data payload (Url and Path).");
                if (data.Url == null) throw new ArgumentException("Missing 'Url' parameter in Enqueue request.");
                if (data.Path == null) throw new ArgumentException("Missing 'Path' parameter in Enqueue request.");

                string url = data.Url.ToString();
                string destinationFolder = data.Path.ToString();

                if (string.IsNullOrWhiteSpace(url)) throw new ArgumentException("Url cannot be empty.");
                if (string.IsNullOrWhiteSpace(destinationFolder)) throw new ArgumentException("Folder cannot be empty.");

                string payloadJson = data.ToString();

                // Start the task and return the assigned ID
                var task = downloadManager.EnqueueDownload(url, destinationFolder, payloadJson);

                responseData = new {
                    Id = task.Id,
                    Url = task.Url,
                    Status = task.Status.ToString()
                };
                break;

            case "QueueList":
                // Retrieve the full list of downloads with status and progress
                responseData = downloadManager.GetTasks()
                    .Select(t =&gt; new {
                        t.Id,
                        t.Url,
                        t.DestinationFilePath,
                        Status = t.Status.ToString(),
                        t.TotalBytes,
                        t.BytesDownloaded,
                        t.ProgressPercentage,
                        t.ErrorMessage
                    }).ToList();
                break;

            case "GetStatus":

                if (data == null) throw new ArgumentException("GetStatus command requires a data payload (DestinationFilePath).");
                string destinationPathToSearch = data.ToString();
                if (string.IsNullOrWhiteSpace(destinationPathToSearch)) throw new ArgumentException("DestinationFilePath cannot be empty.");

                var task2 = downloadManager.GetTasks()
                    .FirstOrDefault(t =&gt; t.DestinationFilePath == destinationPathToSearch);

                if (task2 == null)
                {
                    responseData = null;
                    break;
                }

                if (task2.Status == DownloadStatus.Completed &amp;&amp; !System.IO.File.Exists(task2.DestinationFilePath))
                {
                    downloadManager.DeleteDownload(task2.Id);
                    Program.Log.Info($"Download task {task2.Id} removed (Completed but file missing at: {task2.DestinationFilePath}).");
                    responseData = null;
                    break;
                }

                responseData = new
                {
                    task2.Id,
                    task2.Url,
                    task2.DestinationFilePath,
                    Status = task2.Status.ToString(),
                    task2.TotalBytes,
                    task2.BytesDownloaded,
                    task2.ProgressPercentage,
                    task2.ErrorMessage
                };
                break;

            case "Pause":
            case "Resume":
            case "Delete":
                // Handle control actions (Pause, Resume, Delete) on a specific task ID
                if (data == null) throw new ArgumentException($"{request.Command} command requires a data payload (Id).");
                if (data.Id == null) throw new ArgumentException("Missing Task Id.");

                Guid taskId = Guid.Parse(data.Id.ToString());
                bool operationResult = false;

                switch(request.Command)
                {
                    case "Pause":
                        operationResult = downloadManager.PauseDownload(taskId);
                        break;
                    case "Resume":
                        operationResult = downloadManager.ResumeDownload(taskId);
                        break;
                    case "Delete":
                        operationResult = downloadManager.DeleteDownload(taskId);
                        break;
                }

                responseData = new {
                    Id = taskId,
                    Command = request.Command,
                    Success = operationResult,
                    Message = operationResult ? $"{request.Command} successful." : $"{request.Command} failed or Task not found/ineligible."
                };
                break;

            default:
                success = false;
                responseData = new { Error = $"Unknown command: {request.Command}" };
                break;
        }
    }
    catch (Exception ex)
    {
        // Global error handler: log exception and prepare error response
        success = false;
        Program.Log.Error($"DownloadManager API Error: {request.Command} failed. {ex.Message}");
        responseData = new { Error = ex.Message, Trace = ex.StackTrace };
    }

    // Return the operation result as a JSON object
    return JsonConvert.SerializeObject(new {
        Success = success,
        Data = responseData
    });
});


// Keep the script running in the background
Program.GoBackground();
</ScriptSource>
    <ScriptContext>#using System.Collections.Concurrent
#using System.Net.Http
#using System.Net.Http.Headers

/// &lt;summary&gt;
/// Represents the current state of a download request.
/// &lt;/summary&gt;
public enum DownloadStatus
{
    Pending,        // Waiting to be started
    Downloading,    // Download in progress
    Paused,         // Interrupted by the user (waiting for Resume)
    Error,          // Failed (e.g., HTTP or I/O error)
    Completed,      // Successfully completed
    Cancelled       // Aborted by the user
}

/// &lt;summary&gt;
/// Represents a single download task within the manager.
/// Holds all necessary metadata, state, and control objects.
/// &lt;/summary&gt;
public class DownloadTask : IDisposable
{
    // --- Request and Destination Information ---

    /// &lt;summary&gt;Unique identifier for the download task.&lt;/summary&gt;
    public Guid Id { get; } = Guid.NewGuid();

    /// &lt;summary&gt;The full URL of the resource to be downloaded.&lt;/summary&gt;
    public string Url { get; }

    /// &lt;summary&gt;The destination folder.&lt;/summary&gt;
    public string DestinationFolder { get; }

    /// &lt;summary&gt;The name of the file.&lt;/summary&gt;
    public string FileName { get; }

    /// &lt;summary&gt;
    /// Full path to the destination file (calculated from Folder + FileName).
    /// &lt;/summary&gt;
    public string DestinationFilePath
    {
        get =&gt; Path.Combine(DestinationFolder, FileName);
    }

    /// &lt;summary&gt;Serialized requester payload (e.g., JSON) to be saved in the .info file.&lt;/summary&gt;
    public string OriginatorPayloadJson { get; }

    // --- Status and Progress ---

    /// &lt;summary&gt;The current status of the download.&lt;/summary&gt;
    public DownloadStatus Status { get; set; } = DownloadStatus.Pending;

    /// &lt;summary&gt;Total size of the file in bytes (from HTTP Content-Length header).&lt;/summary&gt;
    public long TotalBytes { get; set; } = 0;

    /// &lt;summary&gt;Number of bytes downloaded so far.&lt;/summary&gt;
    public long BytesDownloaded { get; set; } = 0;

    /// &lt;summary&gt;Calculates the download completion percentage.&lt;/summary&gt;
    public double ProgressPercentage =&gt; TotalBytes &gt; 0
        ? (double)BytesDownloaded / TotalBytes * 100
        : 0;

    /// &lt;summary&gt;Description of the last error, if Status is Error.&lt;/summary&gt;
    public string ErrorMessage { get; set; }

    // --- Control Objects (Pause / Cancel) ---

    /// &lt;summary&gt;
    /// The cancellation token source. Used to signal interruption (Pause/Cancel) to the download operation.
    /// Must be recreated for each start/resume operation.
    /// &lt;/summary&gt;
    public CancellationTokenSource CancellationTokenSource { get; set; }

    /// &lt;summary&gt;The running asynchronous Task that performs the download operation.&lt;/summary&gt;
    public System.Threading.Tasks.Task DownloadOperation { get; set; }

    // --- Utility Properties ---

    public string PartFilePath
    {
        get =&gt; DestinationFilePath + ".part";
    }

    /// &lt;summary&gt;Gets the full path for the metadata file (.info).&lt;/summary&gt;
    public string InfoFilePath
    {
        get
        {
            // Changes extension of the destination file to ".info"
            return Path.ChangeExtension(DestinationFilePath, ".info");
        }
    }

    // --- Constructor ---

    /// &lt;summary&gt;
    /// Initializes a new instance of the DownloadTask class.
    /// &lt;/summary&gt;
    /// &lt;param name="url"&gt;The URL of the file.&lt;/param&gt;
    /// &lt;param name="destinationPath"&gt;The path where the file will be saved.&lt;/param&gt;
    /// &lt;param name="payloadJson"&gt;The JSON payload from the originator.&lt;/param&gt;
    public DownloadTask(string url, string destinationFolder, string payloadJson)
    {
        if (string.IsNullOrWhiteSpace(url)) throw new ArgumentException("URL cannot be empty.", nameof(url));
        if (string.IsNullOrWhiteSpace(destinationFolder)) throw new ArgumentException("Destination folder cannot be empty.", nameof(destinationFolder));

        string calculatedFileName = GetFileNameFromUrl(url);
        if (string.IsNullOrWhiteSpace(calculatedFileName)) throw new ArgumentException("Could not extract a valid file name from the URL.", nameof(url));

        Url = url;
        DestinationFolder = destinationFolder;
        FileName = calculatedFileName;
        OriginatorPayloadJson = payloadJson ?? "{}";
    }

    /// &lt;summary&gt;
    /// Extracts the file name from the given URL string.
    /// &lt;/summary&gt;
    private static string GetFileNameFromUrl(string urlString)
    {
        try
        {
            Uri uri = new Uri(urlString);
            string fileName = Path.GetFileName(uri.LocalPath);

            if (string.IsNullOrWhiteSpace(fileName))
            {
                return "download_" + Guid.NewGuid().ToString().Substring(0, 8);
            }
            return fileName;
        }
        catch (UriFormatException)
        {
            return null;
        }
    }

    // --- IDisposable Implementation ---

    private bool disposed = false;

    /// &lt;summary&gt;
    /// Disposes of unmanaged resources, specifically the CancellationTokenSource.
    /// &lt;/summary&gt;
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                CancellationTokenSource?.Dispose();
            }
            // Dispose unmanaged resources (none applicable here)
            disposed = true;
        }
    }
}


public class DownloadManager : IDisposable
{
    private readonly ConcurrentDictionary&lt;Guid, DownloadTask&gt; _tasks;
    private readonly HttpClient _httpClient;
    private readonly SemaphoreSlim _concurrencyLimiter;
    private const int MaxConcurrentDownloads = 5;

    private bool _disposed = false;

    public DownloadManager()
    {
        _tasks = new ConcurrentDictionary&lt;Guid, DownloadTask&gt;();
        _httpClient = new HttpClient();
        _concurrencyLimiter = new SemaphoreSlim(MaxConcurrentDownloads, MaxConcurrentDownloads);
    }

    /// &lt;summary&gt;
    /// Submits a new download request or registers a task to be managed.
    /// &lt;/summary&gt;
    /// &lt;param name="url"&gt;The file URL.&lt;/param&gt;
    /// &lt;param name="destinationFolder"&gt;The destination folder path.&lt;/param&gt;
    /// &lt;param name="payloadJson"&gt;The custom payload JSON.&lt;/param&gt;
    /// &lt;returns&gt;The created DownloadTask object.&lt;/returns&gt;
    public DownloadTask EnqueueDownload(string url, string destinationFolder, string payloadJson)
    {
        var task = new DownloadTask(url, destinationFolder, payloadJson);
        _tasks.TryAdd(task.Id, task);

        task.DownloadOperation = StartOrResumeDownloadAsync(task);
        return task;
    }

    /// &lt;summary&gt;
    /// Gets a read-only list of all managed download tasks.
    /// &lt;/summary&gt;
    public System.Collections.Generic.IReadOnlyList&lt;DownloadTask&gt; GetTasks()
    {
        return _tasks.Values.ToList();
    }

    /// &lt;summary&gt;
    /// Attempts to pause an active download task.
    /// &lt;/summary&gt;
    public bool PauseDownload(Guid taskId)
    {
        if (_tasks.TryGetValue(taskId, out var task) &amp;&amp; task.Status == DownloadStatus.Downloading)
        {
            // Signaling the CancellationToken will cause the DownloadLoop to exit gracefully.
            task.CancellationTokenSource?.Cancel();
            // The status will be updated to Paused inside the DownloadLoop's catch block.
            return true;
        }
        return false;
    }

    /// &lt;summary&gt;
    /// Resumes a paused task, or starts a pending one if a slot is available.
    /// &lt;/summary&gt;
    public bool ResumeDownload(Guid taskId)
    {
        if (_tasks.TryGetValue(taskId, out var task) &amp;&amp; (task.Status == DownloadStatus.Paused || task.Status == DownloadStatus.Error))
        {
            // Re-start the task; the logic handles resume internally.
            task.DownloadOperation = StartOrResumeDownloadAsync(task);
            return true;
        }
        return false;
    }

    /// &lt;summary&gt;
    /// The core method that manages concurrency and executes the download logic.
    /// &lt;/summary&gt;
    private async System.Threading.Tasks.Task StartOrResumeDownloadAsync(DownloadTask task)
    {
        // Wait for an available concurrency slot.
        await _concurrencyLimiter.WaitAsync();

        if (task.Status == DownloadStatus.Cancelled || task.Status == DownloadStatus.Completed)
        {
            _concurrencyLimiter.Release();
            return;
        }

        // Initialize or recreate the CancellationTokenSource for the new run
        task.CancellationTokenSource?.Dispose();
        task.CancellationTokenSource = new CancellationTokenSource();
        task.Status = DownloadStatus.Downloading;
        task.ErrorMessage = "";

        try
        {
            await DownloadLoop(task, task.CancellationTokenSource.Token);
        }
        catch (OperationCanceledException)
        {
            // Caught when PauseDownload or CancelAllActiveTasks is called.
            if (task.Status != DownloadStatus.Cancelled)
            {
                task.Status = DownloadStatus.Paused;
                task.ErrorMessage = "Paused";
            }
        }
        catch (System.Exception ex)
        {
            // General errors (network, file system, etc.)
            task.Status = DownloadStatus.Error;
            task.ErrorMessage = $"Download failed: {ex.Message}";
        }
        finally
        {
            _concurrencyLimiter.Release();
            // Clean up the CancellationTokenSource
            task.CancellationTokenSource?.Dispose();
            task.CancellationTokenSource = null;
        }
    }

    /// &lt;summary&gt;
    /// Performs the HTTP download logic, handling Range headers for resume and directory creation.
    /// &lt;/summary&gt;
    private async System.Threading.Tasks.Task DownloadLoop(DownloadTask task, CancellationToken cancellationToken)
    {
        var resumeMode = task.BytesDownloaded &gt; 0;
        var request = new HttpRequestMessage(HttpMethod.Get, task.Url);

        if (resumeMode)
        {
            // Range Header logic for resume
            request.Headers.Range = new RangeHeaderValue(task.BytesDownloaded, null);
        }

        using (var response = await _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken))
        {
            response.EnsureSuccessStatusCode();

            if (!resumeMode)
            {
                // Only set TotalBytes on first start
                task.TotalBytes = response.Content.Headers.ContentLength ?? 0;
            }

            var directoryPath = Path.GetDirectoryName(task.DestinationFilePath);
            if (!string.IsNullOrWhiteSpace(directoryPath))
            {
                System.IO.Directory.CreateDirectory(directoryPath);
            }

            // Open existing .part file when resuming a download.
            var fileMode = resumeMode ? System.IO.FileMode.Append : System.IO.FileMode.Create;

            using (var fileStream = new System.IO.FileStream(task.PartFilePath, fileMode, System.IO.FileAccess.Write, System.IO.FileShare.None))
            using (var httpStream = await response.Content.ReadAsStreamAsync())
            {
                var buffer = new byte[81920];
                int bytesRead;

                while ((bytesRead = await httpStream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) &gt; 0)
                {
                    await fileStream.WriteAsync(buffer, 0, bytesRead, cancellationToken);

                    task.BytesDownloaded += bytesRead;
                }
            }

            if (System.IO.File.Exists(task.DestinationFilePath))
            {
                System.IO.File.Delete(task.DestinationFilePath);
            }
            System.IO.File.Move(task.PartFilePath, task.DestinationFilePath);
        }

        // Post-Download Actions
        task.Status = DownloadStatus.Completed;
        await SaveInfoFile(task);
    }

    /// &lt;summary&gt;
    /// Saves the OriginatorPayloadJson to the .info file.
    /// &lt;/summary&gt;
    private System.Threading.Tasks.Task SaveInfoFile(DownloadTask task)
    {
        return System.IO.File.WriteAllTextAsync(task.InfoFilePath, task.OriginatorPayloadJson);
    }

    /// &lt;summary&gt;
    /// Stops the task, removes it from the manager, and deletes associated files (Requirement 5).
    /// &lt;/summary&gt;
    public bool DeleteDownload(Guid taskId)
    {
        if (_tasks.TryRemove(taskId, out var task))
        {
            // 1. Stop the active download immediately (if running)
            task.CancellationTokenSource?.Cancel();
            task.Status = DownloadStatus.Cancelled;

            try
            {
                // 2. Delete main file (even partial one)
                if (System.IO.File.Exists(task.DestinationFilePath))
                {
                    System.IO.File.Delete(task.DestinationFilePath);
                }

                // 2.1 Delete PARTIAL file (.part)
                if (System.IO.File.Exists(task.PartFilePath))
                {
                    System.IO.File.Delete(task.PartFilePath);
                }

                // 3. Delete .info file
                if (System.IO.File.Exists(task.InfoFilePath))
                {
                    System.IO.File.Delete(task.InfoFilePath);
                }

                // 4. Dispose and clean up task resources
                task.Dispose();
                return true;
            }
            catch (System.Exception)
            {
                // Re-add the task if cleanup failed? Depends on desired behavior. For simplicity, just return false.
                return false;
            }
        }
        return false;
    }

    // *****************************************************************
    // * IDisposable Implementation for Cleanup *
    // *****************************************************************

    /// &lt;summary&gt;
    /// Cancels all active (Downloading or Pending) tasks before cleanup.
    /// &lt;/summary&gt;
    public void CancelAllActiveTasks()
    {
        var activeTasks = _tasks.Values
            .Where(t =&gt; t.Status == DownloadStatus.Downloading || t.Status == DownloadStatus.Pending || t.Status == DownloadStatus.Paused)
            .ToList();

        foreach (var task in activeTasks)
        {
            if (task.Status == DownloadStatus.Downloading || task.Status == DownloadStatus.Paused)
            {
                task.Status = DownloadStatus.Cancelled;
                task.CancellationTokenSource?.Cancel();
            }
            else if (task.Status == DownloadStatus.Pending)
            {
                task.Status = DownloadStatus.Cancelled;
            }
        }
    }

    /// &lt;summary&gt;
    /// Releases the unmanaged and managed resources.
    /// &lt;/summary&gt;
    public void Dispose()
    {
        Dispose(true);
        System.GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            // 1. Cancel all active tasks to free up any running threads/tasks
            CancelAllActiveTasks();

            // 2. Dispose managed resources
            _httpClient.Dispose();
            _concurrencyLimiter.Dispose();

            // 3. Dispose of all DownloadTask instances
            foreach(var task in _tasks.Values)
            {
                task.Dispose();
            }
            _tasks.Clear();
        }

        _disposed = true;
    }
}</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>download-manager</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>43F5B501DC7F608D5D0EC644F1ABB330</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>575</Address>
    <Name>Download Manager</Name>
    <Description>A robust, asynchronous HTTP(S) file transfer service accessible via a dedicated API. It manages the full download lifecycle, supporting pause/resume (using Range headers) and temporary file handling (.part).</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddOption("Email.Sender", "", "1. E-Mail address", "text")
  .AddOption("Email.SmtpServer", "", "2. SMTP Mail Server address", "text")
  .AddOption("Email.SmtpUserName", "", "3. SMTP username (optional)", "text")
  .AddOption("Email.SmtpPassword", "", "4. SMTP password (optional)", "password")
  .AddOption("Email.SmtpPort", "25", "5. SMTP Mail Server port", "text")
  .AddOption("Email.SmtpUseSsl", "false", "6. SMTP Mail Server use SSL", "checkbox")
  .Run();
</ScriptSetup>
    <ScriptSource>// detect when an option of this program is changed and store the new value to system settings
When.ModuleParameterChanged((module, parameter)=&gt;{
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
	var settingName = parameter.Name.Substring(17); // skip "ConfigureOptions." part
    Settings.Parameter("Messaging."+settingName).Value = parameter.Value;
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>e-mail-account</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>D5ED1400F10DBDA875BE6EDCE779EB46</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>142</Address>
    <Name>E-Mail Account</Name>
    <Description>Stores e-mail account info used by system programs for sending/receiving emails.</Description>
    <Group>Messaging and Social</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// Run the program's Main
Program.Run();
</ScriptSetup>
    <ScriptSource>// *************************************************************************
// API HANDLER: Weekly Statistics Request (Daily Aggregation)
// Manages the endpoint for retrieving the available week range and the
// average Watts/Hour statistics aggregated by day of the week.
// Format: /Weekly/Meter.Watts.Hour/[Domain]/[Address]/[WeekNumber | BrowsingRange]
// *************************************************************************
Api.Handle("DataProcessing.Statistics/Weekly/Meter.Watts.Hour", (args) =&gt; {
    var request = Api.Parse(args);
    if (request.Command == "BrowsingRange")
    {
        // return results browsing info
        return GetYearWeekRange();
    }
    ushort weekNumber = 0;
    if (ushort.TryParse(request.Command, out weekNumber))
    {
        // return data for "weekNumber"
        return GetWeeklyStats(request.Domain, request.Address, weekNumber);
    }
    // default to current week
    return GetWeeklyStats(request.Domain, request.Address, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now));
});

// *************************************************************************
// API HANDLER: Hourly Statistics Request (Hourly Aggregation)
// Manages the endpoint for retrieving the available week range and the
// average Watts/Hour statistics aggregated by hour of the day.
// Format: /Hourly/Meter.Watts.Hour/[Domain]/[Address]/[WeekNumber | BrowsingRange]
// *************************************************************************
Api.Handle("DataProcessing.Statistics/Hourly/Meter.Watts.Hour", (args) =&gt; {
    var request = Api.Parse(args);
    if (request.Command == "BrowsingRange")
    {
        // return results browsing info
        return GetYearWeekRange();
    }
    ushort weekNumber = 0;
    if (ushort.TryParse(request.Command, out weekNumber))
    {
        // return data for "weekNumber"
        return GetHourlyStats(request.Domain, request.Address, weekNumber);
    }
    // default to current week
    return GetHourlyStats(request.Domain, request.Address, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now));
});

// *************************************************************************
// REAL-TIME DATA UPDATE PROCESS (Downsampling - Mobile Window)
// Recalculates the average Watts consumption for the LAST HOUR (a mobile 60-minute
// window) and logs this rolling average. The process executes at a fixed 60-second
// interval and does NOT align to clock time.
// *************************************************************************
while (Program.IsRunning)
{

    // Calculates for each module average Watt consumption over the last 60 minutes
    var now = DateTime.UtcNow;
    var monitorModules = Modules.WithFeature("EnergyManagement.MonitorWatts");
    monitorModules.Each((mod) =&gt; {

        double defaultValue = mod.Parameter("Meter.Watts").Statistics.Current.Value;

        // NOTE ON DATA INTEGRITY: The underlying device must emit values
        // (including 0.0 when off) at regular intervals for this average to be accurate.
        var records = mod.Parameter("Meter.Watts").Statistics.History
                .FindAll(sv =&gt; sv.Value &gt;= 0 &amp;&amp; sv.Value &lt;= WATT_VALUE_ERROR_MAX &amp;&amp; (now - sv.Timestamp).TotalSeconds &lt; UpdateInterval);

        var avgWatt = records
            .Select(sv =&gt; sv.Value)
            .DefaultIfEmpty(defaultValue)
            .Average();

        mod.Emit("Meter.Watts.Hour", avgWatt);

        // store to database
        UpdateDatabase(mod.Instance, "Meter.Watts.Hour", avgWatt);

        return false;

    });

    // Update stats every minute
    Pause(60);

}
</ScriptSource>
    <ScriptContext>const int UpdateInterval = 3600; // 1 hour
const string DbTable = "weekly";
const double WATT_VALUE_ERROR_MAX = 7000;

class WeeklyStat {
    [BsonId]
    public Int32 ID { get; set; }
    public string Domain { get; set; }
    public string Address { get; set; }
    public byte DayHour { get; set; }
    public byte WeekDay { get; set; }
    public ushort YearWeek { get; set; }
    public string Parameter { get; set; }
    public double WattsHour { get; set; }

    public WeeklyStat() {}
    public WeeklyStat(string domain, string address, string p, double v, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
    {
        Domain = domain;
        Address = address;
        Parameter = p;
        WattsHour = v;
        YearWeek = weekOfYear;
        WeekDay = dayOfWeek;
        DayHour = hourOfDay;
    }
}

bool UpdateDatabase(Module m, string p, double v)
{
    UpdateWeeklyStat(m.Domain, m.Address, p, v, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now), (byte)DateTime.Now.DayOfWeek, (byte)DateTime.Now.Hour);
    return true;
}

bool UpdateWeeklyStat(string domain, string address, string parameter, double wattsHour, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
{
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        var record = stats.FindOne(x =&gt;
                        x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.Parameter == parameter
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == dayOfWeek
                        &amp;&amp; x.DayHour == hourOfDay
                    );
        if (record == null)
        {
            stats.Insert(new WeeklyStat(
                domain,
                address,
                parameter,
                wattsHour,
                weekOfYear,
                dayOfWeek,
                hourOfDay
            ));
        }
        else
        {
            record.WattsHour = wattsHour;
            stats.Update(record);
        }
    }
    return true;
}

double[] GetWeeklyStats(string domain, string address, ushort weekOfYear)
{
    var results = new double[7];
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        for (byte i = 0; i &lt; results.Length; i++)
        {
            var sumValues = stats
                .Find(x =&gt; x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == i);
//                .Sum(x =&gt; x.WattsHour); // &lt;-- this doesn't work with Mono runtime
            double sum = 0;
            foreach(var s in sumValues) {
                sum += s.WattsHour;
            }
            /*    .Select(x =&gt; x.WattsHour)
                  .DefaultIfEmpty(0)
                  .Average();*/
            double avg = sum / 24.0;
            results[i == 0 ? 6 : i - 1] = avg;
        }
    }
    return results;
}

public double[] GetHourlyStats(string domain, string address, ushort targetWeekOfYear)
{
    var results = new double[24];
    ushort weekToFilter = targetWeekOfYear;

    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);

        for (byte i = 0; i &lt; 24; i++) // i = DayHour
        {
            var sumValues = stats
                .Find(x =&gt; x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.YearWeek == weekToFilter
                        &amp;&amp; x.DayHour == i);

            double sum = 0;

            foreach(var s in sumValues) {
                sum += s.WattsHour;
            }

            double avg = sum / 7.0;
            results[i] = avg;
        }
    }
    return results;
}

public object GetYearWeekRange()
{
    ushort minYearWeek = ushort.MaxValue;
    ushort maxYearWeek = 0;
    bool foundAny = false;

    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        var allStats = stats.FindAll();

        foreach (var stat in allStats)
        {
            ushort currentYearWeek = stat.YearWeek;
            if (!foundAny || currentYearWeek &lt; minYearWeek)
            {
                minYearWeek = currentYearWeek;
            }
            if (!foundAny || currentYearWeek &gt; maxYearWeek)
            {
                maxYearWeek = currentYearWeek;
            }
            foundAny = true;
        }
    }

    if (!foundAny)
    {
        ushort currentWeek = (ushort)ISOWeek.GetWeekOfYear(DateTime.Now);
        return new { WeekStart = currentWeek, WeekEnd = currentWeek };
    }

    return new {
        Start = minYearWeek,
        End = maxYearWeek,
        Count = (maxYearWeek - minYearWeek) + 1,
        Step = 1,
        Base = minYearWeek,
        Current = maxYearWeek,
        Label = "week_of_year"
    };
}

public string[] GetDayLabels()
{
    DayOfWeek[] desiredOrder = new DayOfWeek[]
    {
        DayOfWeek.Monday,    // 0
        DayOfWeek.Tuesday,   // 1
        DayOfWeek.Wednesday, // 2
        DayOfWeek.Thursday,  // 3
        DayOfWeek.Friday,    // 4
        DayOfWeek.Saturday,  // 5
        DayOfWeek.Sunday     // 6
    };
    DateTimeFormatInfo dtfi = CultureInfo.CurrentCulture.DateTimeFormat;
    string[] finalLabels = new string[7];
    for (int i = 0; i &lt; 7; i++)
    {
        DayOfWeek day = desiredOrder[i];
        int labelIndex = (int)day;
        finalLabels[i] = dtfi.AbbreviatedDayNames[labelIndex];
    }
    return finalLabels;
}

string GetDbName()
{
    return $"energy_use_{DateTime.Now.Year}.db";
}
</ScriptContext>
    <ScriptErrors>[]</ScriptErrors>
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>energy-use-statistics</Id>
      <Version>1.0.8</Version>
      <Required>false</Required>
      <Checksum>A57965D0B4E782C5ED2B01C6230982B7</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>571</Address>
    <Name>Energy Use Statistics</Name>
    <Description>Continuously monitors, aggregates, and logs energy consumption data (W/h) at regular intervals. Implements a full API for browsing and querying historical datasets.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program
    .AddFeature("", "", EventsLoggingFeature, "Enable events logging", "checkbox")
    .Implements("@Statistics:Storage", EventsLoggingDomain, new {
      icon = "database",
      description = "events_logger_database"
    });
});
Program.Run();
</ScriptSetup>
    <ScriptSource>var loggableModules = Modules.WithFeature(EventsLoggingFeature);

When.ProgramStopping(() =&gt; {
//  db.Dispose();
  return true;
});

When.ModuleParameterChanged((mod, p) =&gt; {
  var m = mod.Get().Instance;
  if (loggableModules.SelectedModules.Contains(m)) {
    lock(mod.Get().Instance)
    using (var db = Data.LiteDb(m.Domain+"@"+m.Address+"-events-log")) {
      var data = new LoggerEvent(m, p);
      try {
        db.Pragma("LIMIT_SIZE", LIMIT_SIZE);
        InsertData(db, data);
      } catch (Exception e) {
        // DB is full, delete some data
        var colCheck = db.GetCollection&lt;LoggerEvent&gt;("events");
        long totalCount = colCheck.LongCount();
        if (totalCount &lt;= MAX_RECORDS_TO_KEEP)
        {
            return true;
        }

        int recordsToSkip = (int)totalCount - MAX_RECORDS_TO_KEEP;
        var limitRecord = colCheck.Query()
            .OrderByDescending(x =&gt; x.UnixTimestamp)
            .Skip(recordsToSkip)
            .Limit(1)
            .SingleOrDefault();
        if (limitRecord != null)
        {
            ObjectId thresholdId = limitRecord.Id;
            int deletedCount = colCheck.DeleteMany(x =&gt; x.Id &lt;= thresholdId);
        }
        /*
        try {
          db.Rebuild();
        } catch (Exception ex) {
          Program.Log.Error(ex);
        }
        */
        // Retry insert
        InsertData(db, data);
      }
    }
  }
  return true;
});

Api.Handle(EventsLoggingDomain, (args) =&gt; {
  var cmd = Api.Parse(args);
  var moduleDomain = cmd.Address;
  var moduleAddress = cmd.Command;
  var module = Modules.InDomain(moduleDomain).WithAddress(moduleAddress);
  var parameter = cmd.GetOption(0);

  if(cmd.GetOption(1) == "TimeRange")
  {
    lock(module.Get().Instance)
    using (var db = Data.LiteDb(moduleDomain+"@"+moduleAddress+"-events-log")) {
      var col = db.GetCollection&lt;LoggerEvent&gt;("events");
      var allResults = col.Query()
          .Where(x =&gt; x.Parameter == parameter)
          .Select(x =&gt; x.UnixTimestamp)
          .ToList();
      if (allResults.Any()) {
            long min = allResults.Min();
            long max = allResults.Max();
            return new { Start = min, End = max, Count = allResults.Count };
      }
      return new { Start = 0L, End = 0L, Count = 0L };
    }
  }

  long? startDateMs = GetUnixMs(cmd.GetOption(1));
  long? endDateMs = GetUnixMs(cmd.GetOption(2));

  int limitRows = -1;
  if (!String.IsNullOrEmpty(cmd.GetOption(3)))
  {
    int.TryParse(cmd.GetOption(3), out limitRows);
  }

  int pageNumber = 1;
  int.TryParse(cmd.GetOption(4), out pageNumber);
  if (pageNumber &lt; 1) pageNumber = 1;

  int skipRows = (pageNumber - 1) * limitRows;

  lock(module.Get().Instance)
  using (var db = Data.LiteDb(moduleDomain+"@"+moduleAddress+"-events-log")) {
    var col = db.GetCollection&lt;LoggerEvent&gt;("events");
    var query = col.Query()
      .Where(x =&gt; x.Parameter == parameter);

    if (startDateMs.HasValue &amp;&amp; startDateMs.Value != 0) {
        query = query.Where(x =&gt; x.UnixTimestamp &gt;= startDateMs.Value);
    }
    if (endDateMs.HasValue &amp;&amp; endDateMs.Value != 0) {
        query = query.Where(x =&gt; x.UnixTimestamp &lt;= endDateMs.Value);
    }

    List&lt;LoggerEvent&gt; results;
    if (limitRows &gt; 0)
    {
      results = query
        .OrderByDescending(x =&gt; x.UnixTimestamp)
        .Skip(skipRows).Limit(limitRows)
        .ToList();
    } else {
    	results = query
        .OrderByDescending(x =&gt; x.UnixTimestamp)
        .ToList();
    }
    return results;
  }
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string EventsLoggingFeature = "EventsLogger.EnableLogging";
const string EventsLoggingDomain = "HomeGenie.EventsLogger";

const int LIMIT_SIZE = 2097152;
const int MAX_RECORDS_TO_KEEP = 100;

long? GetUnixMs(string unixMsString) {
    if (long.TryParse(unixMsString, out long unixTimestampMs)) {
        return unixTimestampMs;
    }
    return null;
}

void InsertData(LiteDatabase db, LoggerEvent data) {
    var col = db.GetCollection&lt;LoggerEvent&gt;("events");
    col.EnsureIndex(x =&gt; x.Parameter);
    col.EnsureIndex(x =&gt; x.UnixTimestamp);
    col.Insert(data);
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>events-logging</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>88F75AD3C5A8957108BF8C649D7A8A00</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>95</Address>
    <Name>Events logging</Name>
    <Description>Records device activity.</Description>
    <Group>Security</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes />
        <Property>EventsLogger.EnableLogging</Property>
        <Description>Enable events logging</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Run();</ScriptSetup>
    <ScriptSource>Api.Handle("HomeAutomation.HomeGenie/FileManager", (args) =&gt; {

    var request = Api.Parse(args);

    string basePath = Path.Combine(Data.GetFolder(), "..");
    string relativeFilePath = request.GetOption(0);

    string responseData = "";
    bool success = true;

    try
    {
        if (string.IsNullOrWhiteSpace(relativeFilePath))
            throw new ArgumentException("Missing relative file path (Option 0) in the request.");

        switch(request.Command) {

            case "Write":
                if (request.Data == null) throw new ArgumentException("Missing content data (request.Data) in the request.");

                FileManagerLogic.WriteFile(basePath, relativeFilePath, (byte[])request.Data);

                responseData = $"File '{relativeFilePath}' successfully written.";
                break;

            case "WriteText":
                if (request.Data is byte[] rawBytes)
                {
                    string contentString = Encoding.UTF8.GetString(rawBytes);
                    FileManagerLogic.WriteFileAsString(basePath, relativeFilePath, contentString);

                    responseData = $"Text file '{relativeFilePath}' successfully written.";
                }
                else
                {
                    throw new ArgumentException("WriteText requires a valid string or byte[] content in the request data.");
                }
                break;

            case "Read":
                byte[] fileContent = FileManagerLogic.ReadFile(basePath, relativeFilePath);

                return fileContent;
                break;

            case "ReadText":
                 string fileStringContent = FileManagerLogic.ReadFileAsString(basePath, relativeFilePath);

                return fileStringContent;
                break;

            default:
                success = false;
                responseData = $"Unknown command: {request.Command}";
                break;
        }
    }
    catch (Exception ex)
    {
        success = false;
        responseData = ex.Message;
    }

    return new ResponseStatus(success ? Status.Ok : Status.Error, responseData);
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>public static class FileManagerLogic
{
    private static string GetSafeFullPath(string basePath, string relativeFilePath)
    {
        if (string.IsNullOrWhiteSpace(basePath))
            throw new ArgumentException("Base path cannot be null or empty.", nameof(basePath));

        if (string.IsNullOrWhiteSpace(relativeFilePath))
            throw new ArgumentException("Relative file path cannot be null or empty.", nameof(relativeFilePath));

        string normalizedFullPath = Path.GetFullPath(relativeFilePath);
        string normalizedBasePath = Path.GetFullPath(basePath);

        if (!normalizedFullPath.StartsWith(normalizedBasePath, StringComparison.OrdinalIgnoreCase))
        {
             throw new UnauthorizedAccessException($"Access denied. Path traversal detected. File must be within: {normalizedBasePath}");
        }

        string? directoryPath = Path.GetDirectoryName(normalizedFullPath);
        if (directoryPath != null &amp;&amp; !Directory.Exists(directoryPath))
        {
            Directory.CreateDirectory(directoryPath);
        }

        return normalizedFullPath;
    }

    public static void WriteFile(string basePath, string relativeFilePath, byte[] contentBytes)
    {
        string fullPath = GetSafeFullPath(basePath, relativeFilePath);
        File.WriteAllBytes(fullPath, contentBytes);
    }

    public static byte[] ReadFile(string basePath, string relativeFilePath)
    {
        string fullPath = GetSafeFullPath(basePath, relativeFilePath);
        if (!File.Exists(fullPath))
        {
             throw new FileNotFoundException($"The file was not found at '{fullPath}'.");
        }
        return File.ReadAllBytes(fullPath);
    }

    public static void WriteFileAsString(string basePath, string relativeFilePath, string contentString)
    {
        byte[] contentBytes = Encoding.UTF8.GetBytes(contentString);
        WriteFile(basePath, relativeFilePath, contentBytes);
    }

    public static string ReadFileAsString(string basePath, string relativeFilePath)
    {
        byte[] fileBytes = ReadFile(basePath, relativeFilePath);
        return Encoding.UTF8.GetString(fileBytes);
    }
}</ScriptContext>
    <ScriptErrors>[]</ScriptErrors>
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>file-manager</Id>
      <Version>1.0.0</Version>
      <Required>true</Required>
      <Checksum>45A509656A53CC9D1A38F8301A04FCD6</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>576</Address>
    <Name>File Manager</Name>
    <Description>A secure, API-driven service for reading and writing files within the program's base data folder. It supports both raw binary and UTF-8 string content via dedicated ReadText and WriteText commands.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements(
    "@Statistics:Provider",
    apiUrl,
    new {
        mode = "select_module",
        field = "Meter.Watts.Hour",
        type = "bar",
        title = "W/h",
        icon = "energy_program_time_used"
    }
).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = apiDataUrl,
        scale = "linear",
        labels = GetHourLabels(),
        refreshMs = 60000, // 1 minute
        browsing = true
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/HourlyStats";
const string apiDataUrl = "DataProcessing.Statistics/Hourly/Meter.Watts.Hour";

public string[] GetHourLabels()
{
    var hourLabels = new List&lt;string&gt;(24);
    for (int hour = 0; hour &lt; 24; hour++)
    {
        string label = $"{hour:D2}h";
        hourLabels.Add(label);
    }
    return hourLabels.ToArray();
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>hourly-energy-use-chart</Id>
      <Version>1.0.0</Version>
      <Required>false</Required>
      <Checksum>E14C3C92075902D2C770A9290C8AC110</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>574</Address>
    <Name>Hourly Energy Consumption</Name>
    <Description>Bar chart displaying the average Watts/Hour consumption for every hour of the day (00h-23h). Data is aggregated over the selected week and sourced from the Energy Use Statistics API.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>true</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program
    .AddOption("ClientId", Program.SystemId, "0. Unique ID for this client", "text")
    .AddOption("ServerAddress", "", "1. MQTT server address", "text")
    .AddOption("ServerPort", "1883", "2. MQTT server port", "text")
    .AddOption("Encryption", "", "3. End-to-end message encryption (E2EE)", "checkbox")
    .AddOption("EncryptionKey", "", "Encryption key", "hidden")
    .AddOption("WebSockets", "", "4. Use WebSockets", "checkbox")
    .AddOption("TLS", "", "5. Enable TLS/SSL", "checkbox")
    .AddOption("Username", "", "6. Username (optional)", "text")
    .AddOption("Password", "", "7. Password (optional)", "text")
    .AddOption("ImportExternal", "", "8. Import external modules", "checkbox");
});

encryptionKey = Program.Option("EncryptionKey").Value;

Program.Run();
</ScriptSetup>
    <ScriptSource>string server = Program.Option("ServerAddress").Value.Trim();
int port = 1883; int.TryParse(Program.Option("ServerPort").Value, out port);
string clientid = Program.Option("ClientId").Value.Trim();
string username = Program.Option("Username").Value.Trim();
string password = Program.Option("Password").Value.Trim();
bool useWebSockets = Program.Option("WebSockets").Value == "On";
bool useTls = Program.Option("TLS").Value == "On";
bool enableEncryption = Program.Option("Encryption").Value == "On";
bool importExternal = Program.Option("ImportExternal").Value == "On";
if (importExternal) {
  Program.Option("Encryption").Value = "";
  enableEncryption = false;
}

var ResponseList = new Dictionary&lt;String, object&gt;();

var MqttIsConnected = false;
MqttClient.Reset();
Program.Emit("MQTT.Status", "configure");

// key used for encryption
byte[] key = Encoding.UTF8.GetBytes(Program.SystemId);

string subscribeTopic = clientid + "/#";
if (enableEncryption) {
  subscribeTopic = encryptTopic(clientid, key) + "/#";
}
if (importExternal) {
  subscribeTopic = "#";
} else {
  // export MQTT-published modules
  Program.AddFeature("", "", "MQTT.SensorPublish", "Publish events emitted by this module", "checkbox");
}

Action&lt;string, string, byte[]&gt; publishBytes = (string cid, string topic, byte[] payload) =&gt; {
  if (enableEncryption) {
    topic = encryptTopic(cid, key) + "/" + encryptTopic(topic, key);
    payload = encryptionFilter(payload, key);
  } else {
    topic = cid + "/" + topic;
  }
  MqttClient.Publish(topic, payload);
};

Action&lt;string, string, string&gt; publish = (string cid, string topic, string message) =&gt; {
  publishBytes(cid, topic, Encoding.UTF8.GetBytes(message));
};

Action&lt;string&gt; apiHandle = (string cid) =&gt; {
  Api.Handle("MQTT:" + cid, ( args ) =&gt; {
    var request = Api.Parse(args);
    var domain = request.Domain;
    var address = request.Address;
    string command = $"{request.Command}/{request.OptionsString}";
    try
    {
      int mqttend = domain.IndexOf(".");
      int mqttdel = domain.IndexOf(":");
      var mqttdest  = domain.Substring(mqttdel + 1, mqttend - mqttdel - 1);
      var mqttsrc = Program.SystemId;
      domain = domain.Substring(mqttend + 1);
      // send request
      var cmd = new MqttCommand(mqttsrc, domain + "/" + address + "/" + command, request.Data);
      var tid = cmd.TransactionId;
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(cmd));
      string payload = Encoding.UTF8.GetString(bytes);
      publish(clientid, "MQTT.Listeners/" + mqttdest + "/command", payload);
      // wait for response
      var res = new ResponseText("ERROR");
      lock (operationLock) ResponseList.Add(tid, res);
      SpinWait.SpinUntil(() =&gt; {
        bool notReady = true;
        try {
          notReady = ResponseList[tid] != res;
        } catch {}
        return notReady;
      }, 10000);
      var response = ResponseList[tid];
      lock (operationLock) ResponseList.Remove(tid);
      return response;
    } catch (Exception e) {
      Program.Notify($"ERROR #2: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
    return new ResponseText("ERROR");
  });
  Api.Handle("HomeAutomation.HomeGenie/Config/Modules.UpdateInfo/MQTT:" + cid, ( args ) =&gt; {
    var request = Api.Parse(args);
    var domain = request.GetOption(0);
    var address = request.GetOption(1);
    try
    {
      int mqttend = domain.IndexOf(".");
      int mqttdel = domain.IndexOf(":");
      var mqttdest  = domain.Substring(mqttdel + 1, mqttend - mqttdel - 1);
      var mqttsrc = Program.SystemId;
      domain = domain.Substring(mqttend + 1);
      string command = $"{request.Domain}/{request.Address}/{request.Command}/{domain}/{address}";
      string jsonPayload = System.Text.Encoding.UTF8.GetString((System.Byte[])request.Data);
      // send request
      var cmd = new MqttCommand(mqttsrc, command, jsonPayload);
      var tid = cmd.TransactionId;
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(cmd));
      string payload = Encoding.UTF8.GetString(bytes);
      publish(clientid, "MQTT.Listeners/" + mqttdest + "/command", payload);
      // wait for response
      var res = new ResponseText("ERROR");
      ResponseList.Add(tid, res);
      SpinWait.SpinUntil(() =&gt; ResponseList[tid] != res, 10000);
      var response = ResponseList[tid];
      ResponseList.Remove(tid);
      return response;
    }
    catch (Exception e)
    {
      Program.Notify($"ERROR #3: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
    return new ResponseText("ERROR");
  });
};

MqttClient.Subscribe(subscribeTopic, (mtopic, bytespayload) =&gt; {
  var parts = mtopic.Split('/');
  var cid = parts[0];
  if (parts.Length == 2) { // encrypted topic
    cid = decryptTopic(cid, key);
    mtopic = decryptTopic(parts[1], key);
    mtopic = cid + "/" + mtopic;
    parts = mtopic.Split('/');
    bytespayload = encryptionFilter(bytespayload, key);
  }
  if (parts.Length == 4)
  {
    try
    {
      var domain = parts[1];
      var address = parts[2];
      var type = parts[3];
      // convert binary message to string
      string mpayload = Encoding.UTF8.GetString(bytespayload);

      var module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();

      switch (type)
      {
        case "command":
        if (domain == "MQTT.Listeners" &amp;&amp; address == clientid)
        {
          var cmdobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
          var targetmodule = Modules.InDomain(cmdobj.Domain.ToString()).WithAddress(cmdobj.Address.ToString());
          if (targetmodule.Get().Instance != null)
          {
            string command = cmdobj.Command.ToString();
            switch (command)
            {
              case "Module.Describe":
              var modinstance = targetmodule.Get().Instance;
              publish(clientid, modinstance.Domain + "/" + modinstance.Address + "/description", Service.Utility.Module2Json(modinstance, false));
              break;
              default:
              var m = targetmodule.Get().Instance;
              var apiCommand = m.Domain + "/" + m.Address + "/" + command;
              var result = Api.Call(apiCommand, cmdobj.Data);
              try {
                result = (byte[])result;
                publishBytes(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", (byte[])result);
              } catch (Exception e) {
                publish(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
              }
              break;
            }
          }
        }
        break;

        case "request":
        var reqobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
        try {
          var result = Api.Call(reqobj.Request.ToString(), reqobj.Data);
          // send response with result
          //if (result != "null") {
            try {
              result = (byte[])result;
              publishBytes(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", (byte[])result);
            } catch (Exception e) {
              publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
            }
          //} else {
          //  publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
          //}
        } catch (Exception e) {
          Program.Notify(e.Message);
        }
        break;

        case "description":
        if (cid != clientid &amp;&amp; module.Instance != null)
        {
          var modobj = JsonConvert.DeserializeObject&lt;Module&gt;(mpayload);
          module.Instance.Name = modobj.Name;
          module.Instance.Description = modobj.Description;
          module.Instance.DeviceType = modobj.DeviceType;
          var parentid = module.Parameter("VirtualModule.ParentId").Value;
          module.Instance.Properties = modobj.Properties;
          module.Parameter("VirtualModule.ParentId").Value = parentid;
          module.Parameter("MQTT.SourceNode").Value = cid;
          //Program.Notify("Imported remote module " + module.Instance.Domain + " " + module.Instance.Address);
        }
        break;

        case "event":
        if (cid != clientid &amp;&amp; importExternal)
        {
          var property = JsonConvert.DeserializeObject&lt;ModuleParameter&gt;(mpayload);
          if (module.Instance == null)
          {
            Program.AddModule("MQTT:" + cid + "." + domain, address, "Sensor", "");
            module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();
            apiHandle(cid);
          }
          else if (!module.HasParameter("MQTT.SourceNode"))
          {
            publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + domain + "', 'Address' : '" + address + "', 'Command' : 'Module.Describe' }");
          }
          module.Emit(property.Name, property.Value);
        }
        break;

        case "response":
        if (cid == clientid)
        {
          var tid = address;
          var responseBody = mpayload;
          if (ResponseList.ContainsKey(tid))
          {
              ResponseList[tid] = bytespayload;
          }
        }
        break;
      }
    } catch (Exception e) {
      Program.Notify($"ERROR #1: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
  }
});

When.ModuleParameterChanged( (module, property) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; property.Name.StartsWith("ConfigureOptions.")) {
    if (Program.IsRunning) Program.Restart();
    return true;
  }
  if (!importExternal &amp;&amp; module.HasFeature("MQTT.SensorPublish") &amp;&amp; !module.Instance.Domain.StartsWith("MQTT:"))
  {
    try{
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(property));
      publishBytes(clientid, module.Instance.Domain + "/" + module.Instance.Address + "/event", bytes);
    } catch  (Exception e){
      //Program.Notify($"ERROR: {e.Message} {OptionButtons}");
      MqttIsConnected = false;
    }
  }
  // returning true, will route event to other listeners
  return true;
});

// Validate configuration

if (String.IsNullOrEmpty(clientid))
{
  clientid = Program.Option("ClientId").Value = Program.SystemId;
}
if (String.IsNullOrEmpty(server))
{
  Program.Notify($"MQTT endpoint is not configured. {OptionButtons}");
  Pause(5);
  return;
}

Action&lt;string&gt; importModules = (string serverAddress) =&gt; {
  try {
    var domain = "HomeAutomation.HomeGenie";
    var data = Net
      .WebService($"http://{serverAddress}/api/{domain}/Config/Modules.List")
      .GetData();
    List&lt;Module&gt; modules = JsonConvert.DeserializeObject&lt;List&lt;Module&gt;&gt;(data.ToString());
    var mini = modules.Find(md =&gt; md.Domain == domain &amp;&amp; (md.Address == "mini" || md.Address == "system"));
    var systemInfo = mini.Properties.Find(p =&gt; p.Name == "System.Info");
    dynamic info = JsonConvert.DeserializeObject(systemInfo.Value);
    string cid = info.Id;
    apiHandle(cid);
    foreach (var m in modules) {
      string type = m.DeviceType.ToString();
      if (type == "Program") continue;
      Program.AddModule("MQTT:" + cid + "." + m.Domain, m.Address, type, "");
      publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + m.Domain + "', 'Address' : '" + m.Address + "', 'Command' : 'Module.Describe' }");
    }
  } catch (Exception e) {
    Program.Notify($"{e.Message}");
  }
};
if (!importExternal)
{
  apiHandle("");
}

while (Program.IsRunning) {

  // Connect to MQTT

  if (!MqttIsConnected) {
    MqttIsConnected = true;
    Program.Notify("Connecting to '" + server + ":" + port + "' ...");
    Program.Emit("MQTT.Status", "connecting");
    try
    {
      if (username != "")
      {
        MqttClient.WithCredentials(username, password);
      }

      MqttClient
        .Service(server)
        .UsingWebSockets(useWebSockets)
        .WithTls(useTls)
        .Connect(port, Guid.NewGuid().ToString(), (connected)=&gt; {
          MqttIsConnected = connected;
          if (connected) {
              Program.Notify("Connected!");
              Program.Emit("MQTT.Status", "connected");
              if (importExternal)
              {
                importModules(server);
              }
          } else {
              Program.Notify("Disconnected!");
              Program.Emit("MQTT.Status", "disconnected");
          }
        });
    }
    catch (Exception e)
    {
      Program.Notify($"{e.Message} {OptionButtons}");
      Pause(5);
      return;
    }
  }

  Pause(30);

}
</ScriptSource>
    <ScriptContext>const string OptionButtons = "[program_configure,program_disable]";
static string encryptionKey = "";
static object operationLock = new object();

static string encryptTopic(string topic, byte[] clientKey) {
    byte[] t = Encoding.UTF8.GetBytes(topic);
    t = encryptionFilter(t, clientKey);

    string encryptedTopic = Convert.ToBase64String(t);
    encryptedTopic = encryptedTopic.Replace("/", "%");
    encryptedTopic = encryptedTopic.Replace("+", "&amp;");

    return encryptedTopic;
}

static string decryptTopic(string topic, byte[] clientKey) {
    topic = topic.Replace("%", "/");
    topic = topic.Replace("&amp;", "+");
    byte[] encryptedTopic = Convert.FromBase64String(topic);
    return Encoding.UTF8.GetString(encryptionFilter(encryptedTopic, clientKey));
}

static byte[] encryptionFilter(byte[] payload, byte[] clientKey) {
    if (!String.IsNullOrEmpty(encryptionKey)) {
        byte[] output = new byte[256];
        byte[] k = Convert.FromBase64String(encryptionKey);
        k = andFilter(k, clientKey);
        payload = xorFilter(payload, k);
    }
    return payload;
}

static byte[] xorFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k ^ i);
            payload[c] = o;
        }
    }
    return payload;
}

static byte[] andFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k &amp; i);
            payload[c] = o;
        }
    }
    return payload;
}

class MqttCommand: MigInterfaceCommand {
    public MqttCommand(string cid, string request, object data): base(request, data) {
        ClientId = cid;
        TransactionId = Guid.NewGuid().ToString();
    }
    public string ClientId {get; set;} = "";
    public string TransactionId {get; set;} = "";
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>mqtt-network</Id>
      <Version>1.0.9</Version>
      <Required>true</Required>
      <Checksum>8C0D66916C7D8071C71AA2527BE73D97</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>77</Address>
    <Name>MQTT Network</Name>
    <Description>Connect to an MQTT broker to use HomeGenie Panel app from anywhere via Internet or to interconnect HomeGenie devices on the same MQTT network.</Description>
    <Group>Interconnections</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>true</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>false</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// list the program as custom weather widget
Program.UseWidget( "homegenie/environment/weather" )
  // set input fields parameters
  // &lt;field_name&gt;, &lt;default_value&gt;, &lt;description&gt;
  .AddOption("Location", "London, UK", "City name", "wunderground.city")
  .AddOption("Language", "EN", "Language", "text")
  .AddOption("ApiKey", "?", "OpenWeatherMap API key (APPID)", "text")
  .AddOption("UpdateInterval", "30", "Update interval (minutes)", "slider:15:1440:15:15");

// initialize widget program parameters
Program.Parameter("Astronomy.Sunset").Value = "";
Program.Parameter("Astronomy.Sunrise").Value = "";
Program.Parameter("Conditions.City").Value = "";
Program.Parameter("Conditions.DisplayLocation").Value = "";
Program.Parameter("Conditions.IconType").Value = "";
Program.Parameter("Conditions.Description").Value = "";
Program.Parameter("Sensor.Temperature").Value = "22.44";

Program.Parameter("EventsLogger.EnableLogging").Value = "On";
Program.Run();
</ScriptSetup>
    <ScriptSource>Action&lt;dynamic&gt; UpdateWeatherParameters = (data) =&gt; {
  Program
    .Emit("Conditions.City", data.city)
    .Emit("Conditions.DisplayLocation", data.city)
    .Emit("Conditions.Country", data.country)
    .Emit("Conditions.Description", data.weather_description)
    .Emit("Conditions.IconType", data.weather_icon)
    .Emit("Conditions.Status", data.weather_status) // eg. cloudy, sunny, etc..
    .Emit("Conditions.LastUpdated", data.update_dt)
    // Add values to standard Sensor.* parameters
    .Emit("Sensor.Temperature", data.temperature)
    .Emit("Sensor.Temperature.Unit", "Celsius")
    .Emit("Sensor.Pressure", data.pressure)
    .Emit("Sensor.Pressure.Unit", "Mb")
    .Emit("Sensor.Wind.Speed", data.wind_speed)
    .Emit("Sensor.Wind.Speed.Unit", "Kph")
    .Emit("Sensor.Wind.Direction", data.wind_direction)
    .Emit("Sensor.Precipitation.Rain", data.rain_1h_mm)
    .Emit("Sensor.Precipitation.Rain.Unit", "1h")
    .Emit("Sensor.Precipitation.Snow", data.snow_1h_mm)
    .Emit("Sensor.Precipitation.Snow.Unit", "1h");
  // TODO: Program.Parameter("Sensor.UV").Value = "...";
};
Action&lt;int,dynamic&gt; UpdateForecastParameters = (day, data) =&gt; {
  Program
    .Emit("Conditions.Forecast." + day + ".Description", data.weather_description)
    .Emit("Conditions.Forecast." + day + ".Year", data.dt.Year.ToString("YYYY"))
    .Emit("Conditions.Forecast." + day + ".Month", data.dt.ToString("MMM"))
    .Emit("Conditions.Forecast." + day + ".Day", data.dt.ToString("dd"))
    .Emit("Conditions.Forecast." + day + ".Weekday", data.dt.ToString("dddd"))
    .Emit("Conditions.Forecast." + day + ".IconType", data.weather_icon)
    .Emit("Conditions.Forecast." + day + ".Temperature", data.temperature)
    .Emit("Conditions.Forecast." + day + ".Temperature.Min", data.temperature_min)
    .Emit("Conditions.Forecast." + day + ".Temperature.Max", data.temperature_max);
};
Func&lt;string,string&gt; GetWeatherIcon = (type) =&gt; {
  var icon = type;
  switch(type)
  {
    case "clear": // 	clear sky
      icon = "01d";
      break;
    case "partlycloudy": // 	few clouds
      icon = "02d";
      break;
    case "scatteredclouds": // scattered clouds
      icon = "03d";
      break;
    case "cloudy": // broken clouds (?)
      icon = "04d";
      break;
    case "showerrain": // 	shower rain
      icon = "09d";
      break;
    case "rain": // rain
      icon = "10d";
      break;
    case "thunderstorms": // thunderstorms
      icon = "11d";
      break;
    case "snow": // snow
      icon = "13d";
      break;
    case "hazy": // mist
      icon = "50d";
      break;
    // Night icons
    case "clear_night": // 	clear sky
      icon = "01n";
      break;
    case "partlycloudy_night": // 	few clouds
      icon = "02n";
      break;
    case "scatteredclouds_night": // scattered clouds
      icon = "03n";
      break;
    case "cloudy_night": // broken clouds (?)
      icon = "04n";
      break;
    case "showerrain_night": // 	shower rain
      icon = "09n";
      break;
    case "rain_night": // rain
      icon = "10n";
      break;
    case "thunderstorms_night": // thunderstorms
      icon = "11n";
      break;
    case "snow_night": // snow
      icon = "13n";
      break;
    case "hazy_night": // mist
      icon = "50n";
      break;
  }
  return icon;
};
Func&lt;dynamic, dynamic&gt; CollectWeatherData = (weatherData) =&gt; {
  dynamic data = new ExpandoObject();
  data.dt = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.dt);
  data.update_dt = data.dt.ToLongDateString() + " " + TimeZoneInfo.ConvertTime(data.dt, TimeZoneInfo.Local).ToLongTimeString();
  data.temperature = weatherData.main.temp.ToString();
  data.temperature_min = weatherData.main.temp_min.ToString();
  data.temperature_max = weatherData.main.temp_max.ToString();
  data.pressure = weatherData.main.pressure.ToString();
  var rain_1h_mm = "0";
  var rain_3h_mm = "0";
  if (weatherData.rain != null) {
    if (weatherData.rain["1h"] != null)
      rain_1h_mm = weatherData.rain["1h"].ToString();
    if (weatherData.rain["3h"] != null)
      rain_3h_mm = weatherData.rain["3h"].ToString();
  }
  data.rain_1h_mm = rain_1h_mm;
  var snow_1h_mm = "0";
  var snow_3h_mm = "0";
  if (weatherData.snow != null) {
    if (weatherData.snow["1h"] != null)
      snow_1h_mm = weatherData.snow["1h"].ToString();
    if (weatherData.snow["3h"] != null)
      snow_3h_mm = weatherData.snow["3h"].ToString();
  }
  data.snow_1h_mm = snow_1h_mm;
  data.wind_speed = weatherData.wind.speed.ToString();
  data.wind_direction = "";
  if (weatherData.wind.deg != null)
  	data.wind_direction = weatherData.wind.deg.ToString();
  data.weather_status = weatherData.weather[0].main.ToString();
  data.weather_description = weatherData.weather[0].description.ToString();
  data.weather_icon = GetWeatherIcon(weatherData.weather[0].icon.ToString());
  // city and country fields are not present in forecast data
  if (weatherData.name != null)
  	data.city = weatherData.name.ToString();
  if (weatherData.sys != null &amp;&amp; weatherData.sys.country != null)
  	data.country = weatherData.sys.country.ToString();
  return data;
};

bool reconfigureRequired = false;
When.ModuleParameterChanged((module, parameter) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
    reconfigureRequired = true;
  }
  return true;
});

while (Program.IsRunning)
{
  string location = Program.Option("Location").Value;
  string language = Program.Option("Language").Value;
  string apikey = Program.Option("ApiKey").Value.Trim();

  if (!apikey.Contains("?") &amp;&amp; apikey.Length &gt; 0)
  {
    try
    {
      string webserviceurl = "https://api.openweathermap.org/data/2.5/weather?q=" + location + "&amp;lang=" + language + "&amp;units=metric&amp;appid=" + apikey;
      var weatherData = Net.WebService(webserviceurl).GetData();

      var sunset = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunset);
      var sunrise = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunrise);

      Program.Emit("Astronomy.Sunset", TimeZoneInfo.ConvertTime(sunset, TimeZoneInfo.Local).ToShortTimeString());
      Program.Emit("Astronomy.Sunrise", TimeZoneInfo.ConvertTime(sunrise, TimeZoneInfo.Local).ToShortTimeString());

      var data = CollectWeatherData(weatherData);
      UpdateWeatherParameters(data);

      // get forecast data
	  webserviceurl = "https://api.openweathermap.org/data/2.5/forecast?q=" + location + "&amp;lang="+language+"&amp;units=metric&amp;appid=" + apikey;
      var forecast = Net.WebService(webserviceurl).GetData();

      var forecastDay = 1;
      var nextDay = DateTime.UtcNow.AddDays(1); nextDay = nextDay.Date + new TimeSpan(12, 0, 0);
      foreach(var fc in forecast.list)
      {
        var forecastTime = Utility.JavaTimeStampToDateTime(1000D*(int)fc.dt);
        if (forecastTime.Equals(nextDay)) {
          // collect forecast data for current forecastDay

          var forecastData = CollectWeatherData(fc);
          UpdateForecastParameters(forecastDay, forecastData);

          nextDay = nextDay.AddDays(1);
          forecastDay++;
        }
        // process up to 3 days
        if (forecastDay &gt; 3) break;
      }
      //Program.Emit("Program.UiRefresh", "Data Updated");

    }
    catch (Exception e)
    {

      Program.Notify("ERROR: unable to get data from service. " + e.Message);
      Console.WriteLine( e.Message );
      Pause(10);

    }
  }
  //
  var delayMins = Program.Option("UpdateInterval").DecimalValue;
  if (delayMins &lt; 1) delayMins = 1;
  double pauseBeforeNextUpdate = delayMins*60; // seconds
  while (pauseBeforeNextUpdate-- &gt; 0 &amp;&amp; !reconfigureRequired) {
	  Pause(1);
  }
  reconfigureRequired = false;
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>openweathermap</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>C84E2793CF3B0CA530B08855628D8786</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>34</Address>
    <Name>OpenWeatherMap</Name>
    <Description>Weather and forecast information from Open Weather Map service.
To activate this widget enter a valid API key.
Follow instructions at https://openweathermap.org/appid to get a free API key.
</Description>
    <Group>Weather and Environment</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// This method is used to register this program as a Chart provider
Program.Implements(
    "@Statistics:Provider",
    apiUrl,
     // the following param's value can be:
     // --&gt; "select_module", "select_property" or "select_none"
    new {
        mode = "select_none",
        legend = true,
        icon = "pie_chart"
    }
).Run();
</ScriptSetup>
    <ScriptSource>// This API method will be called by the chart component
// to get the configuration of the chart to generate
Api.Handle(apiUrl, (args) =&gt; {
    return new {
        // API url to call to get updated chart data from this program
        dataApi = dataApiUrl,
        // Chart configuration
        scale = "linear",
        type = "doughnut",
        title = "kW/h today",
        labels = new string[] {
            "🍗 Oven",
            "🔥 Boiler",
            "❄️ Refrigerator",
            "🍹 Living Room",
            "📖 Study"
        },
        colors = new string[] {
            "rgb(197,137,64)",
            "rgb(229,186,115)",
            "rgb(250,234,177)",
            "rgb(255,247,218)",
            "rgb(255,253,244)"
        },
        refreshMs = 1800000, // 30 minutes
        // Other chart.js options (see https://www.chartjs.org/)
        options = new {
            scales = new {
                x = new {
                    display = false
                },
                y = new {
                    display = false
                }
            }
        }
    };
});

// API method implementation
Api.Handle(dataApiUrl, (args) =&gt; {
    // Just a demo, return fixed data
    return new double[] {
        700, 400, 200, 200, 100
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/ExamplePieChart";
const string dataApiUrl = "DataProcessing.Statistics/MyStat";

</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>pie-chart-stats-example</Id>
      <Version>1.0.2</Version>
      <Required>false</Required>
      <Checksum>D8F2F884BB3010580313BB3073D1347E</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>572</Address>
    <Name>Pie Chart Stats example</Name>
    <Description>Example chart provider that renders as a pie chart with static data.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.Enable", "Enable remote control", "checkbox")
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.IRCode", "Toggle button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerUpCode", "ButtonUp", "1. Bright button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerDownCode", "ButtonDown", "2. Dim button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerInterval", "10", "4. Dimming step %", "slider:5:50:5")
  .Run();
</ScriptSetup>
    <ScriptSource>var dimmerInterval = Program.Option("DimmerInterval");
var dimmerUp = Program.Option("DimmerUpCode");
var dimmerDown = Program.Option("DimmerDownCode");
var irControlModules = Modules.WithFeature("HomeGenie.RemoteControl.Enable");

When.ModuleParameterChanged((module, parameter) =&gt; {
  if(parameter.Name == "Receiver.RawData" )
  {
    var irData = parameter;
    var lastButton = module.Parameter("IrController.LastButton");
    var lastIdle = module.Parameter("IrController.LastIdle");
    var dimStep = dimmerInterval.DecimalValue / 100D;

    if (irData.Value != "")
    {
      if (lastButton.Value != "" &amp;&amp; lastIdle.IdleTime &gt; 0.25 &amp;&amp; (irData.Value == dimmerUp.Value || irData.Value == dimmerDown.Value))
      {
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == lastButton.Value)
          {
            var level = m.Level;
            if (irData.Value == dimmerUp.Value)
            {
              level += dimStep;
              m.Level = (level &gt;= 1 ? 1 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Bright (" + m.Level + ")");
            }
            else if (irData.Value == dimmerDown.Value)
            {
              level -= dimStep;
              m.Level = (level &lt;= 0.05 ? 0.05 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Dim (" + m.Level + ")");
            }
            lastIdle.Value = "0";
          }
          return false; // do not break, continue iterating...
        });
      }
      else
      {
        if (lastIdle.IdleTime &gt; 0.5)
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == irData.Value)
          {
            lastButton.Value = irData.Value;
            lastIdle.Value = "1";
            m.Toggle();
            Program.Notify(m.Instance.Name + "&lt;br&gt;toggled.");
          }
          return false; // do not break, continue iterating...
        });
      }
    }
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>remote-control</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>F55B4203889EEC49B831E1F1AF765BCD</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>505</Address>
    <Name>Remote Control</Name>
    <Description>Toggle and dim the device using a remote controller (IR or RF).</Description>
    <Group>Lights</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.Enable</Property>
        <Description>Enable remote control</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>capture:Receiver.RawData</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.IRCode</Property>
        <Description>Toggle button (enter code)</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.UseWidget("homegenie/generic/sensor");
//Program.Run();</ScriptSetup>
    <ScriptSource>#using NWaves.Signals.Builders
// For NWaves DSP library documentation see:
// https://github.com/ar1st0crat/NWaves?tab=readme-ov-file

DiscreteSignal sinusoid =
    new SineBuilder()
        .SetParameter("frequency", 200/*Hz*/)
        .SetParameter("phase", Math.PI)
        .OfLength(444)
        .SampledAt(44444/*Hz*/)
        .Build();

var samples = new List&lt;float&gt;(sinusoid.Samples);
while (Program.IsRunning)
{
    foreach (var s in samples)
    {
        double v = (s * .5) + .5;
        Program.Emit("Sensor.SineWave", v * 1000);
        // synchronize level of a module with sinewave values [0.0 .. 1.0]
        /*
        Program.RunAsyncTask(()=&gt;{
            Modules
                .WithAddress("S4")
                .Level = v;
        });
        */
        Pause(.05);
    }
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>sine-wave-signal</Id>
      <Version>1.0.3</Version>
      <Required>false</Required>
      <Checksum>F09D3EDBC3FE43F726DEE5A8D7F496E2</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>900</Address>
    <Name>SineWave Signal</Name>
    <Description>Example</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>false</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements(
    "@Statistics:Provider",
    apiUrl,
    new {
        mode = "select_module",
        field = "Meter.Watts.Hour",
        type = "bar",
        title = "W/h",
        icon = "analytics"
    }
).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = apiDataUrl,
        scale = "linear",
        labels = GetDayLabels(),
        refreshMs = 60000, // 1 minute
        browsing = true
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/WeeklyStats";
const string apiDataUrl = "DataProcessing.Statistics/Weekly/Meter.Watts.Hour";

public string[] GetDayLabels()
{
    DayOfWeek[] desiredOrder = new DayOfWeek[]
    {
        DayOfWeek.Monday,    // 0
        DayOfWeek.Tuesday,   // 1
        DayOfWeek.Wednesday, // 2
        DayOfWeek.Thursday,  // 3
        DayOfWeek.Friday,    // 4
        DayOfWeek.Saturday,  // 5
        DayOfWeek.Sunday     // 6
    };
    DateTimeFormatInfo dtfi = CultureInfo.CurrentCulture.DateTimeFormat;
    string[] finalLabels = new string[7];
    for (int i = 0; i &lt; 7; i++)
    {
        DayOfWeek day = desiredOrder[i];
        int labelIndex = (int)day;
        finalLabels[i] = dtfi.AbbreviatedDayNames[labelIndex];
    }
    return finalLabels;
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.4</PackageVersion>
      <Id>weekly-energy-use-chart</Id>
      <Version>1.0.0</Version>
      <Required>false</Required>
      <Checksum>B584D065DD0AE78A064665351C41495E</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>573</Address>
    <Name>Weekly Energy Consumption</Name>
    <Description>Bar chart displaying the average Watts/Hour consumption for each day of the week (Mon-Sun). Data is aggregated across all hours of the day and sourced from the Energy Use Statistics API.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
</ArrayOfProgramBlock>