<?xml version="1.0" encoding="utf-8"?>
<ArrayOfProgramBlock xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <ProgramBlock>
    <ScriptSetup>Program.Run();
</ScriptSetup>
    <ScriptSource>// ===================================================================
// MULTI-STORE CHAT HISTORY SERVICE
// ===================================================================

string dataFolder = Data.GetFolder();

Api.Handle("System.Utility/ChatHistory", (args) =&gt; {
    var request = Api.Parse(args);

    dynamic data = (request.Data is string) ? JObject.Parse((string)request.Data) : JObject.FromObject(request.Data);

    string storeId = data?.StoreId?.ToString() ?? "default";
    var currentHistory = HistoryStore.GetStore(dataFolder, storeId);

    switch(request.Command) {

        case "Get":

            return currentHistory;

        case "Add":

            var msg = JsonConvert.DeserializeObject&lt;ChatMessage&gt;(data.Message.ToString());
            if (msg != null) {
                currentHistory.Add(msg);
                HistoryStore.Save(dataFolder, storeId);
            }
            return new { Count = currentHistory.Count };

        case "PopLast":

            if (currentHistory.Count &gt; 0) {
                currentHistory.RemoveAt(currentHistory.Count - 1);
                HistoryStore.Save(dataFolder, storeId);
            }
            return new { Count = currentHistory.Count };

        case "Clear":

            currentHistory.Clear();
            HistoryStore.Save(dataFolder, storeId);
            return new { Status = "Cleared" };

        default:
            return new ResponseStatus(Status.Error, $"Unknown command: {request.Command}");
    }
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>
// --- POJO MODELS ---

public class MessagePart
{
    [JsonProperty("text")]
    public string Text { get; set; }
}

public class ChatMessage
{
    [JsonProperty("role")]
    public string Role { get; set; }
    [JsonProperty("parts")]
    public List&lt;MessagePart&gt; Parts { get; set; } = new List&lt;MessagePart&gt;();

    public static ChatMessage Create(string role, string text)
    {
        return new ChatMessage {
            Role = role,
            Parts = new List&lt;MessagePart&gt; { new MessagePart { Text = text } }
        };
    }
}

// --- MULTI-STORE PERSISTENCE ---

public static class HistoryStore
{
    // Dizionario che tiene in memoria le diverse cronologie caricate
    public static Dictionary&lt;string, List&lt;ChatMessage&gt;&gt; Stores { get; set; } = new Dictionary&lt;string, List&lt;ChatMessage&gt;&gt;();

    private static string GetFilePath(string folder, string storeId)
    {
        return Path.Combine(folder, $"history_{storeId}.json");
    }

    public static List&lt;ChatMessage&gt; GetStore(string folder, string storeId)
    {
        if (!Stores.ContainsKey(storeId))
        {
            Load(folder, storeId);
        }
        return Stores[storeId];
    }

    public static bool Load(string folder, string storeId)
    {
        try {
            string path = GetFilePath(folder, storeId);
            if (File.Exists(path)) {
                var list = JsonConvert.DeserializeObject&lt;List&lt;ChatMessage&gt;&gt;(File.ReadAllText(path));
                Stores[storeId] = list ?? new List&lt;ChatMessage&gt;();
                return true;
            }
        } catch { }
        Stores[storeId] = new List&lt;ChatMessage&gt;();
        return false;
    }

    public static bool Save(string folder, string storeId)
    {
        try {
            if (!Stores.ContainsKey(storeId)) return false;
            string path = GetFilePath(folder, storeId);
            File.WriteAllText(path, JsonConvert.SerializeObject(Stores[storeId], Formatting.Indented));
            return true;
        } catch { return false; }
    }
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>chat-history-service</Id>
      <Version>1.0.0</Version>
      <Required>true</Required>
      <Checksum>F9D8FF9BC10DC6A37F321E56444BAA64</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>577</Address>
    <Name>Chat History Service</Name>
    <Description>Centralized HomeGenie service for managing and persisting AI chat logs. Through a unified API (System.Utility/ChatHistory), it provides cloud and local LLMs with a shared context, automated JSON storage, and real-time history management.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>var dataFolder = Data.GetFolder(PresetsFolder);
Data.AddToSystemBackup(dataFolder);
Program.Run();
</ScriptSetup>
    <ScriptSource>var dataFolder = Data.GetFolder(PresetsFolder);

Api.Handle($"{apiBaseUrl}List", (args) =&gt; {
    var files = Directory.GetFiles(dataFolder);
    return files.Select(f =&gt; Path.GetFileNameWithoutExtension(f));
});
Api.Handle($"{apiBaseUrl}Add/", (args) =&gt; {
    var command = Api.Parse(args);
    if (command.Data != null) {
        var configuration = System.Text.Encoding.Default.GetString(command.Data as byte[]);
        var presetName = command.GetOption(0);
        if (String.IsNullOrEmpty(presetName)) {
            presetName = "default";
        }
        var dataFile = Path.Combine(dataFolder, presetName + ".json");
        File.WriteAllText(dataFile, configuration);
    }
    return new ResponseStatus(Status.Ok);
});
Api.Handle($"{apiBaseUrl}Get/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        presetName = "default";
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    var config = "{config: null, preferences: null}";
    if (File.Exists(dataFile)) config = File.ReadAllText(dataFile);
    return config;
});
Api.Handle($"{apiBaseUrl}Delete/", (args) =&gt; {
    var command = Api.Parse(args);
    var presetName = command.GetOption(0);
    if (String.IsNullOrEmpty(presetName)) {
        return new ResponseStatus(Status.Error);
    }
    var dataFile = Path.Combine(dataFolder, presetName + ".json");
    File.Delete(dataFile);
    return new ResponseStatus(Status.Ok);
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string PresetsFolder = "client-presets";
const string apiBaseUrl = "HomeAutomation.HomeGenie/Config/Client.Presets";
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>client-configs</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>0BE01D06C8342351AC31E74439BA6022</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>111</Address>
    <Name>Client configuration</Name>
    <Description>Implements API for managing client's configuration profiles that are used to store client's UI and dashboards settings.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// This method is used to register this program as a Chart provider
Program.Setup(() =&gt; {
  Program.Implements(
    "@Statistics:Provider",
    ApiUrl,
     // the following param's value can be:
     // --&gt; "select_module", "select_property" or "select_none"
    new {
        mode = "select_none",
        legend = true,
        icon = "bar_chart"
    }
  ).AddFeature("", "Light,Dimmer,Color,Switch,Sensor : /^Meter.Watts$/", WidgetStatisticsReport, "Include in Daily Wh report", "checkbox");
});
Program.Run();
</ScriptSetup>
    <ScriptSource>var reportModules = Modules.WithFeature(WidgetStatisticsReport);

// Helper lambda to resolve the YAML file path.
// Logic:
// 1. If 'year' and 'day' are provided, construct that specific path.
// 2. If they are missing, scan the directory to find the absolute latest data.
var GetYamlDataPath = (string year = null, string day = null) =&gt; {
    // We pass 'year' to GetDataFilesInfo so it calculates the correct 'Last' day for that specific year
    // instead of the last day of the latest year.
    var dataFilesInfo = GetDataFilesInfo(Data.GetFolder(), YamlFileSuffix, year);

    var y = !string.IsNullOrWhiteSpace(year) ? year : dataFilesInfo.Archive.Current;
    var d = !string.IsNullOrWhiteSpace(day) ? day : dataFilesInfo.Current;

    return Path.Combine(Data.GetFolder(), y, $"{y}_{d}{YamlFileSuffix}");
};

// -----------------------------------------------------------------------------
// API Handler: Widget Configuration
// Returns chart settings (Title, Type, Options) for a SPECIFIC date.
// -----------------------------------------------------------------------------
Api.Handle(ApiUrl, (args) =&gt; {
    var request = Api.Parse(args);

    // Parse arguments. Option(0) = Year, Command = Day.
    string reqYear = request.GetOption(0)?.Trim();
    string reqDay = request.Command?.Trim();

    // Load the configuration for the requested date.
    // If args are null, GetYamlDataPath resolves to the latest file.
    var config = LoadConfig(GetYamlDataPath(reqYear, reqDay));

    var timeLabels = GetTimeLabels();
    var workersConfig = new List&lt;object&gt;();

    // Map datasets to worker configurations if valid data exists
    if (config.Datasets != null)
    {
        for (int i = 0; i &lt; config.Datasets.Count; i++)
        {
            var ds = config.Datasets[i];

            // Build dynamic options object (camelCase for JS)
            dynamic options = new ExpandoObject();
            options.type = ds.Type;

            // Only map properties that are explicitly set in the YAML
            if (ds.BackgroundColor != null) options.backgroundColor = ds.BackgroundColor;
            if (ds.BorderColor != null) options.borderColor = ds.BorderColor;
            if (ds.BorderWidth != null) options.borderWidth = ds.BorderWidth;
            if (ds.Fill != null) options.fill = ds.Fill;
            if (ds.Tension != null) options.tension = ds.Tension;

            workersConfig.Add(new {
                title = ds.Label,
                queryOptions = new {
                    datasetIndex = i
                },
                chartOptions = options
            });
        }
    }

    return new {
        dataApi = DataApiUrl,
        title = config.Title,
        scale = config.Scale,
        labels = timeLabels,
        options = config.Options,
        refreshMs = config.RefreshMs,
        datasetConfigs = workersConfig,
        browsing = true
    };
});

// -----------------------------------------------------------------------------
// API Handler: Data Retrieval
// Returns raw numeric data or browsing metadata.
// -----------------------------------------------------------------------------
Api.Handle(DataApiUrl, (args) =&gt; {
    var request = Api.Parse(args);
    var year = request.GetOption(0)?.Trim();

    // Mode 1: Return Navigation Metadata (List of years/days)
    if (request.Command == "BrowsingRange")
    {
        return GetDataFilesInfo(Data.GetFolder(), YamlFileSuffix, year);
    }

    // Mode 2: Return Specific Dataset Values
    if (!String.IsNullOrEmpty(request.Command))
    {
        // Resolve path: Command is the Day. Option 0 is the Year.
        string path = GetYamlDataPath(year, request.Command.Trim());
        var config = LoadConfig(path);

        // Determine dataset index.
        // If year is present, index is Option 1. If year is missing, index might be Option 0.
        int datasetIndex = 0;
        string indexOpt = !string.IsNullOrEmpty(year) ? request.GetOption(1) : request.GetOption(0);

        if (!string.IsNullOrEmpty(indexOpt))
        {
            int.TryParse(indexOpt, out datasetIndex);
        }

        if (config != null &amp;&amp; config.Datasets != null &amp;&amp; datasetIndex &gt;= 0 &amp;&amp; datasetIndex &lt; config.Datasets.Count)
        {
            return config.Datasets[datasetIndex].Data;
        }
    }

    return new List&lt;double&gt;();
});


// Main execution loop: Aggregates hourly data and saves to daily YAML files.
while (Program.IsRunning)
{
    // 1. Determine the file path for TODAY
    var now = DateTime.Now;
    var year = now.Year.ToString();
    var day = now.DayOfYear.ToString("000"); // Zero-padding recommended for sorting (e.g., 015)

    // Structure: /DataFolder/YYYY/YYYY_DDD_daily_stats.yaml
    var folderPath = Path.Combine(Data.GetFolder(), year);
    var filePath = Path.Combine(folderPath, $"{year}_{day}{YamlFileSuffix}");

    // Ensure the year directory exists
    if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath);

    // 2. Load existing data (or create empty config if it's a new day)
    var config = LoadConfig(filePath);

    // Initialize datasets list if new file
    if (config.Datasets == null) config.Datasets = new List&lt;YamlDataset&gt;();

    // 3. Iterate over enabled modules
    bool dataChanged = false;

    reportModules.Each(m =&gt; {
        var moduleId = $"{m.Instance.Domain}:{m.Instance.Address}";
        // Read the rolling hourly average value calculated by the MonitorWatts program
        var wattsHour = m.Parameter("Meter.Watts.Hour").DecimalValue;

        // Find corresponding dataset
        var dataset = config.Datasets.FirstOrDefault(d =&gt; d.Label == moduleId);

        // Create new dataset if module is encountered for the first time
        if (dataset == null)
        {
            dataset = new YamlDataset
            {
                Type = "bar", // Default chart type
                Label = moduleId,
                Data = new double[24].ToList() // Initialize 24 hours with 0
            };
            config.Datasets.Add(dataset);
        }

        // Ensure array has 24 elements (safety for corrupted/legacy files)
        while (dataset.Data.Count &lt; 24) dataset.Data.Add(0);

        // 4. Write value to the current hour slot
        // Round to 2 decimals for clean output
        dataset.Data[now.Hour] = Math.Round(wattsHour, 2);

        dataChanged = true;
        return false; // Continue iteration
    });

    // 5. Save to disk if data changed
    if (dataChanged)
    {
        SaveConfig(filePath, config);
    }

    // Wait 1 minute before next update cycle
    Pause(60);
}</ScriptSource>
    <ScriptContext>const string YamlFileSuffix = "_daily_stats.yaml";
const string ApiUrl = "Statistics.Providers/DailyEnergyReport";
const string DataApiUrl = "DataProcessing.Statistics/DailyEnergyReport";
const string WidgetStatisticsReport = "Widget.Statistics.DailyReport";

public class YamlDataset
{
    public string Type { get; set; }
    public string Label { get; set; }
    public List&lt;double&gt; Data { get; set; }
    public string BackgroundColor { get; set; }
    public string BorderColor { get; set; }
    public int? BorderWidth { get; set; }
    public bool? Fill { get; set; }
    public double? Tension { get; set; }
}

public class YamlConfig
{
    public string Title { get; set; }
    public string Scale { get; set; }
    public int RefreshMs { get; set; }
    public object Options { get; set; }
    public List&lt;YamlDataset&gt; Datasets { get; set; }
}

/// &lt;summary&gt;
/// Deserializes a YAML file. Returns an empty config on failure.
/// &lt;/summary&gt;
YamlConfig LoadConfig(string yamlFilePath)
{
    try
    {
        if (System.IO.File.Exists(yamlFilePath))
        {
            var yaml = System.IO.File.ReadAllText(yamlFilePath);
            var deserializer = new YamlDotNet.Serialization.DeserializerBuilder()
                .WithNamingConvention(YamlDotNet.Serialization.NamingConventions.CamelCaseNamingConvention.Instance)
                .IgnoreUnmatchedProperties()
                .Build();
            return deserializer.Deserialize&lt;YamlConfig&gt;(yaml);
        }
    }
    catch (Exception e)
    {
        Console.WriteLine(e.Message);
    }
    return new YamlConfig { Datasets = new List&lt;YamlDataset&gt;() };
}

/// &lt;summary&gt;
/// Generates a list of hourly time labels (e.g., "00h", "01h", ..., "23h") for the chart X-axis.
/// &lt;/summary&gt;
List&lt;string&gt; GetTimeLabels()
{
    var labels = new List&lt;string&gt;();
    var start = DateTime.Today;
    for (int i = 0; i &lt; 24; i++)
    {
        labels.Add(start.AddHours(i).ToString("HH") + 'h');
    }
    return labels;
}

/// &lt;summary&gt;
/// Scans folders to determine available years and days.
/// Returns metadata used by the frontend for navigation controls.
/// &lt;/summary&gt;
dynamic GetDataFilesInfo(string rootPath, string suffix, string inputYear = "")
{
    // 1. Get all year folders
    var yearFolders = Directory.GetDirectories(rootPath)
                           .Select(path =&gt; new DirectoryInfo(path).Name) // Safer than Path.GetFileName for dirs
                           .OrderBy(y =&gt; y)
                           .ToList();

    // 2. Determine target year
    string currentYear = DateTime.Now.Year.ToString();

    if (!string.IsNullOrEmpty(inputYear) &amp;&amp; yearFolders.Contains(inputYear))
    {
        currentYear = inputYear;
    }
    else if (yearFolders.Any())
    {
        currentYear = yearFolders.Last();
    }

    // 3. Scan days within the selected year
    var daysList = new List&lt;string&gt;();
    string selectedYearPath = Path.Combine(rootPath, currentYear);

    if (Directory.Exists(selectedYearPath))
    {
        string searchPattern = $"{currentYear}_*{suffix}";

        foreach (string filePath in Directory.EnumerateFiles(selectedYearPath, searchPattern))
        {
            string fileName = Path.GetFileName(filePath);

            // Extract "Day" part from "Year_Day_Suffix"
            int prefixLength = currentYear.Length + 1;
            int variablePartLength = fileName.Length - prefixLength - suffix.Length;

            if (variablePartLength &gt; 0)
            {
                string dayString = fileName.Substring(prefixLength, variablePartLength);
                daysList.Add(dayString);
            }
        }
    }

    daysList.Sort();

    string currentDay = daysList.LastOrDefault() ?? "";
    string lastAvailableDay = daysList.LastOrDefault() ?? "";

    return new {
        Label = "day_of_year",
        Items = daysList.ToArray(),
        Current = currentDay,
        Last = lastAvailableDay,

        Archive = new {
            Label = "year",
            Items = yearFolders.ToArray(),
            Current = currentYear
        }
    };
}

/// &lt;summary&gt;
/// Serializes the configuration object to YAML format and writes it to the specified file path.
/// Null values are omitted to keep the output clean.
/// &lt;/summary&gt;
void SaveConfig(string filePath, YamlConfig config)
{
    try
    {
        var serializer = new YamlDotNet.Serialization.SerializerBuilder()
            .WithNamingConvention(YamlDotNet.Serialization.NamingConventions.CamelCaseNamingConvention.Instance)
            .ConfigureDefaultValuesHandling(YamlDotNet.Serialization.DefaultValuesHandling.OmitNull)
            .Build();

        var yaml = serializer.Serialize(config);
        File.WriteAllText(filePath, yaml);
    }
    catch (Exception ex)
    {
        //Console.WriteLine("Error: " + ex.Message);
    }
}</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>daily-energy-report</Id>
      <Version>1.0.0</Version>
      <Required>false</Required>
      <Checksum>C26D27C2F9B6748BF9AAA2C2DCE300EB</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>579</Address>
    <Name>Daily Energy Summary</Name>
    <Description>Daily energy consumption (Wh) by device.</Description>
    <Group>Data Processing</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes>Light,Dimmer,Color,Switch,Sensor : /^Meter.Watts$/</ForTypes>
        <Property>Widget.Statistics.DailyReport</Property>
        <Description>Include in Daily Wh report</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements("@Statistics:Provider", ApiUrl, new {
    icon = "legend_toggle"
}).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(ApiUrl, (args) =&gt; {
    return new {
        dataApi = DataApiUrl,
        scale = "time",
        filters = new string[] {
            "SimpleAverage",
            "MovingAverage",
            "SavitzkyGolay"
        }
    };
});


var ParseArgs = new Func&lt;object, MigInterfaceCommand&gt;((args) =&gt; {
    string storageDomain = "";
    string requestString = args is string ? args.ToString() : (args as MigInterfaceCommand).OriginalRequest;
    int storageIndex = requestString.IndexOf("@");
    if (storageIndex &gt; 0) {
        storageDomain = requestString.Substring(storageIndex + 1).Split("/")[0];
        var delimiter = $"@{storageDomain}/";
        requestString = requestString.Substring(requestString.IndexOf(delimiter) + delimiter.Length);
    }
    return new MigInterfaceCommand(requestString, storageDomain);
});


Api.Handle($"{DataApiUrl}/TimeRange", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        if (string.IsNullOrEmpty(storageDomain))
        {
            // default data storage endpoint
            storageDomain = "HomeAutomation.HomeGenie/Config/Modules.StatisticsGet";
        }
        return Api.Call($"{storageDomain}/{module.Instance.Domain}/{module.Instance.Address}/{parameter.Name}/TimeRange");
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/RawData", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        try
        {
            var stats = GetRawData(storageDomain, module.Instance, parameter, startTime, endTime);
            stats.Reverse();
            return stats;
        }
        catch (Exception e)
        {
            return e;
        }
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});


Api.Handle($"{DataApiUrl}/SimpleAverage", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));
        try
        {
            var stats = ApplySimpleAverageFilter(storageDomain, module.Instance, parameter, startTime, endTime, chartWidth);
            stats.Reverse();
            return stats;
        }
        catch (Exception e)
        {
            return e;
        }
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/MovingAverage", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new MovingAverageFilter(windowSize);
        var stats = ApplyFilter(storageDomain, filter, module.Instance, parameter, startTime, endTime, chartWidth);
        stats.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Api.Handle($"{DataApiUrl}/SavitzkyGolay", (args) =&gt; {
    var request = ParseArgs(args);
    var storageDomain = request.Data.ToString();
    var module = Modules.InDomain(request.Domain)
                        .WithAddress(request.Address)
                        .Get();
    if (module.Exists) {
        var parameter = module.Parameter(request.Command);
        var startTime = double.Parse(request.GetOption(0));
        var endTime = double.Parse(request.GetOption(1));
        var chartWidth = double.Parse(request.GetOption(2));

        var filter = new SavitzkyGolayFilter(windowSize);
        var stats = ApplyFilter(storageDomain, filter, module.Instance, parameter, startTime, endTime, chartWidth);
        stats.Reverse();
        return stats;
    }
    return new ResponseStatus(Status.Error, $"Unknown module '{request.Domain}:{request.Address}'");
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>#using StatValue = HomeGenie.Data.ValueStatistics.StatValue

const string ApiUrl = "Statistics.Providers/DataMonitor";
const string DataApiUrl = "DataProcessing.Filters/Series";

const int windowSize = 9;

List&lt;StatValue&gt; GetRawData(string storageDomain, Module module, ModuleParameter parameter, double startTime, double endTime)
{
    startTime = (long)startTime;
    endTime = (long)endTime;

    var stats = new ValueStatistics();

    if (String.IsNullOrEmpty(storageDomain)) {
        // Read from runtime Statistics History
        stats.History = new TsList&lt;StatValue&gt;(
                parameter.Statistics.History
                    .Where(sv =&gt; sv != null &amp;&amp; sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
                    .ToList()
            );
    } else {
        // Read from persistent database provider (such as Event Logger or remote cloud service)
        var results = (List&lt;LoggerEvent&gt;)Api.Call($"{storageDomain}/{module.Domain}/{module.Address}/{parameter.Name}/{startTime}/{endTime}");
        stats.History = new TsList&lt;StatValue&gt;(results
            .Select(logEvent =&gt; {
                string ev = logEvent.Value?.ToString().Replace(",", ".") ?? string.Empty;
                double value;
                if (!double.TryParse(ev, NumberStyles.Any, CultureInfo.InvariantCulture, out value))
                {
                    value = double.NaN;
                }
                return new StatValue(value, DateTimeOffset.FromUnixTimeMilliseconds(logEvent.UnixTimestamp).UtcDateTime);
            }).Where(sv =&gt; !double.IsNaN(sv.Value)).ToList());
    }

    var data = stats.History;
    data.Reverse();
    return data;
}

List&lt;StatValue&gt; ApplySimpleAverageFilter(string storageDomain, Module module, ModuleParameter parameter, double startTime, double endTime, double chartWidth)
{
    var data = GetRawData(storageDomain, module, parameter, startTime, endTime);
    // Process time series
    if (startTime &gt; 0 &amp;&amp; data.Count &gt; 0 &amp;&amp; chartWidth &lt; data.Count)
    {
        var cts = data.First().UnixTimestamp;
        var cte = data.Last().UnixTimestamp;
        var stepMs = ((endTime - startTime) / chartWidth) * ((cte - cts) / (endTime - startTime));
        if (stepMs &lt; 1000) stepMs = 1000;
        var resampledList = new List&lt;StatValue&gt;();
        cts -= (cts % stepMs);
        cts -= stepMs;
        var sum = 0D;
        var count = 0;
        int i = 0;
        var itemTimestamp = DateTime.UtcNow;
        while (i &lt; data.Count)
        {
            var item = data[i];
            if (item.UnixTimestamp &gt;= cts)
            {
                var resampled = new StatValue(
                    sum / count,
                    itemTimestamp
                );
                resampledList.Add(resampled);
                sum =0; count = 0;
                cts += stepMs;
            }
            sum += item.Value;
            itemTimestamp = item.Timestamp;
            count++;
            i++;
        }
        data = new TsList&lt;StatValue&gt;(resampledList);
    }
    return data;
}

List&lt;StatValue&gt; ApplyFilter(string storageDomain, NWaves.Filters.Base.IFilter filter, Module module, ModuleParameter parameter, double startTime, double endTime, double chartWidth) {
    var timeSpan = (endTime - startTime);
    var timeSpanMin = (timeSpan / 2);
    var data = ApplySimpleAverageFilter(storageDomain, module, parameter, startTime - timeSpanMin, endTime + timeSpanMin, chartWidth);

    // Process time series
    var samples = data
        .Select(sv =&gt; (float)sv.Value)
        .ToArray();
    var signal = new DiscreteSignal(50/*Hz sampling rate*/, samples);
    var smoothedSignal = filter.ApplyTo(signal);
    var lst = new List&lt;StatValue&gt;();
    int boundsGap = (windowSize - 1) / 2;
    for (int c = 0; c &lt; data.Count - boundsGap; c++)
    {
        var sv = data[c];
        if (sv.UnixTimestamp &gt;= startTime &amp;&amp; sv.UnixTimestamp &lt;= endTime)
        {
            lst.Add(new StatValue(smoothedSignal[c + boundsGap], sv.Timestamp));
        }
    }

    data = new TsList&lt;StatValue&gt;(lst);
    return data;
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>stats-data-monitor</Id>
      <Version>1.0.5</Version>
      <Required>true</Required>
      <Checksum>F7945A866C7285570C60C48B592CC37F</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>570</Address>
    <Name>Data Monitor</Name>
    <Description>Centralized analysis service for historical module statistics. It enables dynamic retrieval of time-series data with built-in signal processing filters (Simple Average, Moving Average, Savitzky-Golay) to provide clean, smoothed data for charts and system monitoring.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Run();</ScriptSetup>
    <ScriptSource>// Initialize the central download manager
var downloadManager = new DownloadManager();

// Ensure resources are released when the program stops
When.ProgramStopping(() =&gt; {
    downloadManager.Dispose();
    return true;
});

// Define the API endpoint for DownloadManager interactions
Api.Handle("System.Utility/DownloadManager", (args) =&gt; {

    var request = Api.Parse(args);
    dynamic data = null;

    // Attempt to deserialize input data (handles both string and byte arrays)
    try
    {
        string jsonString = request.Data is string ? request.Data.ToString() : System.Text.Encoding.UTF8.GetString((byte[])request.Data);
        data = JsonConvert.DeserializeObject&lt;dynamic&gt;(jsonString);
    }
    catch (Exception ex)
    {
        data = request.Data?.ToString();
    }

    object responseData = null;
    bool success = true;

    try
    {
        // Handle different operations based on the 'Command' parameter
        switch(request.Command) {

            case "Enqueue":
                // Validate inputs and add a new download to the queue
                if (data == null) throw new ArgumentException("Enqueue command requires a data payload (Url and Path).");
                if (data.Name == null) throw new ArgumentException("Missing 'Name' parameter in Enqueue request.");
                if (data.Url == null) throw new ArgumentException("Missing 'Url' parameter in Enqueue request.");
                if (data.Path == null) throw new ArgumentException("Missing 'Path' parameter in Enqueue request.");

                string url = data.Url.ToString();
                string destinationFolder = Path.Combine(data.Path.ToString(), Path.GetDirectoryName(data.Name.ToString()));

                if (string.IsNullOrWhiteSpace(url)) throw new ArgumentException("Url cannot be empty.");
                if (string.IsNullOrWhiteSpace(destinationFolder)) throw new ArgumentException("Folder cannot be empty.");

                string payloadJson = data.ToString();

                // Start the task and return the assigned ID
                var task = downloadManager.EnqueueDownload(url, destinationFolder, payloadJson);

                responseData = new {
                    Id = task.Id,
                    Url = task.Url,
                    Status = task.Status.ToString()
                };
                break;

            case "QueueList":
                // Retrieve the full list of downloads with status and progress
                responseData = downloadManager.GetTasks()
                    .Select(t =&gt; new {
                        t.Id,
                        t.Url,
                        t.DestinationFilePath,
                        Status = t.Status.ToString(),
                        t.TotalBytes,
                        t.BytesDownloaded,
                        t.ProgressPercentage,
                        t.ErrorMessage
                    }).ToList();
                break;

            case "GetStatus":

                if (data == null) throw new ArgumentException("GetStatus command requires a data payload (DestinationFilePath).");
                string destinationPathToSearch = data.ToString();
                if (string.IsNullOrWhiteSpace(destinationPathToSearch)) throw new ArgumentException("DestinationFilePath cannot be empty.");

                var task2 = downloadManager.GetTasks()
                    .FirstOrDefault(t =&gt; t.DestinationFilePath == destinationPathToSearch);

                if (task2 == null)
                {
                    responseData = null;
                    break;
                }

                if (task2.Status == DownloadStatus.Completed &amp;&amp; !System.IO.File.Exists(task2.DestinationFilePath))
                {
                    downloadManager.DeleteDownload(task2.Id);
                    Program.Log.Info($"Download task {task2.Id} removed (Completed but file missing at: {task2.DestinationFilePath}).");
                    responseData = null;
                    break;
                }

                responseData = new
                {
                    task2.Id,
                    task2.Url,
                    task2.DestinationFilePath,
                    Status = task2.Status.ToString(),
                    task2.TotalBytes,
                    task2.BytesDownloaded,
                    task2.ProgressPercentage,
                    task2.ErrorMessage
                };
                break;

            case "Pause":
            case "Resume":
            case "Delete":
                // Handle control actions (Pause, Resume, Delete) on a specific task ID
                if (data == null) throw new ArgumentException($"{request.Command} command requires a data payload (Id).");
                if (data.Id == null) throw new ArgumentException("Missing Task Id.");

                Guid taskId = Guid.Parse(data.Id.ToString());
                bool operationResult = false;

                switch(request.Command)
                {
                    case "Pause":
                        operationResult = downloadManager.PauseDownload(taskId);
                        break;
                    case "Resume":
                        operationResult = downloadManager.ResumeDownload(taskId);
                        break;
                    case "Delete":
                        operationResult = downloadManager.DeleteDownload(taskId);
                        break;
                }

                responseData = new {
                    Id = taskId,
                    Command = request.Command,
                    Success = operationResult,
                    Message = operationResult ? $"{request.Command} successful." : $"{request.Command} failed or Task not found/ineligible."
                };
                break;

            default:
                success = false;
                responseData = new { Error = $"Unknown command: {request.Command}" };
                break;
        }
    }
    catch (Exception ex)
    {
        // Global error handler: log exception and prepare error response
        success = false;
        Program.Log.Error($"DownloadManager API Error: {request.Command} failed. {ex.Message}");
        responseData = new { Error = ex.Message, Trace = ex.StackTrace };
    }

    // Return the operation result as a JSON object
    return JsonConvert.SerializeObject(new {
        Success = success,
        Data = responseData
    });
});


// Keep the script running in the background
Program.GoBackground();
</ScriptSource>
    <ScriptContext>#using System.Collections.Concurrent
#using System.Net.Http
#using System.Net.Http.Headers

/// &lt;summary&gt;
/// Represents the current state of a download request.
/// &lt;/summary&gt;
public enum DownloadStatus
{
    Pending,        // Waiting to be started
    Downloading,    // Download in progress
    Paused,         // Interrupted by the user (waiting for Resume)
    Error,          // Failed (e.g., HTTP or I/O error)
    Completed,      // Successfully completed
    Cancelled       // Aborted by the user
}

/// &lt;summary&gt;
/// Represents a single download task within the manager.
/// Holds all necessary metadata, state, and control objects.
/// &lt;/summary&gt;
public class DownloadTask : IDisposable
{
    // --- Request and Destination Information ---

    /// &lt;summary&gt;Unique identifier for the download task.&lt;/summary&gt;
    public Guid Id { get; } = Guid.NewGuid();

    /// &lt;summary&gt;The full URL of the resource to be downloaded.&lt;/summary&gt;
    public string Url { get; }

    /// &lt;summary&gt;The destination folder.&lt;/summary&gt;
    public string DestinationFolder { get; }

    /// &lt;summary&gt;The name of the file.&lt;/summary&gt;
    public string FileName { get; }

    /// &lt;summary&gt;
    /// Full path to the destination file (calculated from Folder + FileName).
    /// &lt;/summary&gt;
    public string DestinationFilePath
    {
        get =&gt; Path.Combine(DestinationFolder, FileName);
    }

    /// &lt;summary&gt;Serialized requester payload (e.g., JSON) to be saved in the .info file.&lt;/summary&gt;
    public string OriginatorPayloadJson { get; }

    // --- Status and Progress ---

    /// &lt;summary&gt;The current status of the download.&lt;/summary&gt;
    public DownloadStatus Status { get; set; } = DownloadStatus.Pending;

    /// &lt;summary&gt;Total size of the file in bytes (from HTTP Content-Length header).&lt;/summary&gt;
    public long TotalBytes { get; set; } = 0;

    /// &lt;summary&gt;Number of bytes downloaded so far.&lt;/summary&gt;
    public long BytesDownloaded { get; set; } = 0;

    /// &lt;summary&gt;Calculates the download completion percentage.&lt;/summary&gt;
    public double ProgressPercentage =&gt; TotalBytes &gt; 0
        ? (double)BytesDownloaded / TotalBytes * 100
        : 0;

    /// &lt;summary&gt;Description of the last error, if Status is Error.&lt;/summary&gt;
    public string ErrorMessage { get; set; }

    // --- Control Objects (Pause / Cancel) ---

    /// &lt;summary&gt;
    /// The cancellation token source. Used to signal interruption (Pause/Cancel) to the download operation.
    /// Must be recreated for each start/resume operation.
    /// &lt;/summary&gt;
    public CancellationTokenSource CancellationTokenSource { get; set; }

    /// &lt;summary&gt;The running asynchronous Task that performs the download operation.&lt;/summary&gt;
    public System.Threading.Tasks.Task DownloadOperation { get; set; }

    // --- Utility Properties ---

    public string PartFilePath
    {
        get =&gt; DestinationFilePath + ".part";
    }

    /// &lt;summary&gt;Gets the full path for the metadata file (.info).&lt;/summary&gt;
    public string InfoFilePath
    {
        get
        {
            // Changes extension of the destination file to ".info"
            return Path.ChangeExtension(DestinationFilePath, ".info");
        }
    }

    // --- Constructor ---

    /// &lt;summary&gt;
    /// Initializes a new instance of the DownloadTask class.
    /// &lt;/summary&gt;
    /// &lt;param name="url"&gt;The URL of the file.&lt;/param&gt;
    /// &lt;param name="destinationPath"&gt;The path where the file will be saved.&lt;/param&gt;
    /// &lt;param name="payloadJson"&gt;The JSON payload from the originator.&lt;/param&gt;
    public DownloadTask(string url, string destinationFolder, string payloadJson)
    {
        if (string.IsNullOrWhiteSpace(url)) throw new ArgumentException("URL cannot be empty.", nameof(url));
        if (string.IsNullOrWhiteSpace(destinationFolder)) throw new ArgumentException("Destination folder cannot be empty.", nameof(destinationFolder));

        string calculatedFileName = GetFileNameFromUrl(url);
        if (string.IsNullOrWhiteSpace(calculatedFileName)) throw new ArgumentException("Could not extract a valid file name from the URL.", nameof(url));

        Url = url;
        DestinationFolder = destinationFolder;
        FileName = calculatedFileName;
        OriginatorPayloadJson = payloadJson ?? "{}";
    }

    /// &lt;summary&gt;
    /// Extracts the file name from the given URL string.
    /// &lt;/summary&gt;
    private static string GetFileNameFromUrl(string urlString)
    {
        try
        {
            Uri uri = new Uri(urlString);
            string fileName = Path.GetFileName(uri.LocalPath);

            if (string.IsNullOrWhiteSpace(fileName))
            {
                return "download_" + Guid.NewGuid().ToString().Substring(0, 8);
            }
            return fileName;
        }
        catch (UriFormatException)
        {
            return null;
        }
    }

    // --- IDisposable Implementation ---

    private bool disposed = false;

    /// &lt;summary&gt;
    /// Disposes of unmanaged resources, specifically the CancellationTokenSource.
    /// &lt;/summary&gt;
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                CancellationTokenSource?.Dispose();
            }
            // Dispose unmanaged resources (none applicable here)
            disposed = true;
        }
    }
}


public class DownloadManager : IDisposable
{
    private readonly ConcurrentDictionary&lt;Guid, DownloadTask&gt; _tasks;
    private readonly HttpClient _httpClient;
    private readonly SemaphoreSlim _concurrencyLimiter;
    private const int MaxConcurrentDownloads = 5;

    private bool _disposed = false;

    public DownloadManager()
    {
        _tasks = new ConcurrentDictionary&lt;Guid, DownloadTask&gt;();
        _httpClient = new HttpClient();
        _concurrencyLimiter = new SemaphoreSlim(MaxConcurrentDownloads, MaxConcurrentDownloads);
    }

    /// &lt;summary&gt;
    /// Submits a new download request or registers a task to be managed.
    /// &lt;/summary&gt;
    /// &lt;param name="url"&gt;The file URL.&lt;/param&gt;
    /// &lt;param name="destinationFolder"&gt;The destination folder path.&lt;/param&gt;
    /// &lt;param name="payloadJson"&gt;The custom payload JSON.&lt;/param&gt;
    /// &lt;returns&gt;The created DownloadTask object.&lt;/returns&gt;
    public DownloadTask EnqueueDownload(string url, string destinationFolder, string payloadJson)
    {
        var task = new DownloadTask(url, destinationFolder, payloadJson);
        _tasks.TryAdd(task.Id, task);

        task.DownloadOperation = StartOrResumeDownloadAsync(task);
        return task;
    }

    /// &lt;summary&gt;
    /// Gets a read-only list of all managed download tasks.
    /// &lt;/summary&gt;
    public System.Collections.Generic.IReadOnlyList&lt;DownloadTask&gt; GetTasks()
    {
        return _tasks.Values.ToList();
    }

    /// &lt;summary&gt;
    /// Attempts to pause an active download task.
    /// &lt;/summary&gt;
    public bool PauseDownload(Guid taskId)
    {
        if (_tasks.TryGetValue(taskId, out var task) &amp;&amp; task.Status == DownloadStatus.Downloading)
        {
            // Signaling the CancellationToken will cause the DownloadLoop to exit gracefully.
            task.CancellationTokenSource?.Cancel();
            // The status will be updated to Paused inside the DownloadLoop's catch block.
            return true;
        }
        return false;
    }

    /// &lt;summary&gt;
    /// Resumes a paused task, or starts a pending one if a slot is available.
    /// &lt;/summary&gt;
    public bool ResumeDownload(Guid taskId)
    {
        if (_tasks.TryGetValue(taskId, out var task) &amp;&amp; (task.Status == DownloadStatus.Paused || task.Status == DownloadStatus.Error))
        {
            // Re-start the task; the logic handles resume internally.
            task.DownloadOperation = StartOrResumeDownloadAsync(task);
            return true;
        }
        return false;
    }

    /// &lt;summary&gt;
    /// The core method that manages concurrency and executes the download logic.
    /// &lt;/summary&gt;
    private async System.Threading.Tasks.Task StartOrResumeDownloadAsync(DownloadTask task)
    {
        // Wait for an available concurrency slot.
        await _concurrencyLimiter.WaitAsync();

        if (task.Status == DownloadStatus.Cancelled || task.Status == DownloadStatus.Completed)
        {
            _concurrencyLimiter.Release();
            return;
        }

        // Initialize or recreate the CancellationTokenSource for the new run
        task.CancellationTokenSource?.Dispose();
        task.CancellationTokenSource = new CancellationTokenSource();
        task.Status = DownloadStatus.Downloading;
        task.ErrorMessage = "";

        try
        {
            await DownloadLoop(task, task.CancellationTokenSource.Token);
        }
        catch (OperationCanceledException)
        {
            // Caught when PauseDownload or CancelAllActiveTasks is called.
            if (task.Status != DownloadStatus.Cancelled)
            {
                task.Status = DownloadStatus.Paused;
                task.ErrorMessage = "Paused";
            }
        }
        catch (System.Exception ex)
        {
            // General errors (network, file system, etc.)
            task.Status = DownloadStatus.Error;
            task.ErrorMessage = $"Download failed: {ex.Message}";
        }
        finally
        {
            _concurrencyLimiter.Release();
            // Clean up the CancellationTokenSource
            task.CancellationTokenSource?.Dispose();
            task.CancellationTokenSource = null;
        }
    }

    /// &lt;summary&gt;
    /// Performs the HTTP download logic, handling Range headers for resume and directory creation.
    /// &lt;/summary&gt;
    private async System.Threading.Tasks.Task DownloadLoop(DownloadTask task, CancellationToken cancellationToken)
    {
        var resumeMode = task.BytesDownloaded &gt; 0;
        var request = new HttpRequestMessage(HttpMethod.Get, task.Url);

        if (resumeMode)
        {
            // Range Header logic for resume
            request.Headers.Range = new RangeHeaderValue(task.BytesDownloaded, null);
        }

        using (var response = await _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken))
        {
            response.EnsureSuccessStatusCode();

            if (!resumeMode)
            {
                // Only set TotalBytes on first start
                task.TotalBytes = response.Content.Headers.ContentLength ?? 0;
            }

            var directoryPath = Path.GetDirectoryName(task.DestinationFilePath);
            if (!string.IsNullOrWhiteSpace(directoryPath))
            {
                System.IO.Directory.CreateDirectory(directoryPath);
            }

            // Open existing .part file when resuming a download.
            var fileMode = resumeMode ? System.IO.FileMode.Append : System.IO.FileMode.Create;

            using (var fileStream = new System.IO.FileStream(task.PartFilePath, fileMode, System.IO.FileAccess.Write, System.IO.FileShare.None))
            using (var httpStream = await response.Content.ReadAsStreamAsync())
            {
                var buffer = new byte[81920];
                int bytesRead;

                while ((bytesRead = await httpStream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) &gt; 0)
                {
                    await fileStream.WriteAsync(buffer, 0, bytesRead, cancellationToken);

                    task.BytesDownloaded += bytesRead;
                }
            }

            if (System.IO.File.Exists(task.DestinationFilePath))
            {
                System.IO.File.Delete(task.DestinationFilePath);
            }
            System.IO.File.Move(task.PartFilePath, task.DestinationFilePath);
        }

        // Post-Download Actions
        task.Status = DownloadStatus.Completed;
        await SaveInfoFile(task);
    }

    /// &lt;summary&gt;
    /// Saves the OriginatorPayloadJson to the .info file.
    /// &lt;/summary&gt;
    private System.Threading.Tasks.Task SaveInfoFile(DownloadTask task)
    {
        return System.IO.File.WriteAllTextAsync(task.InfoFilePath, task.OriginatorPayloadJson);
    }

    /// &lt;summary&gt;
    /// Stops the task, removes it from the manager, and deletes associated files (Requirement 5).
    /// &lt;/summary&gt;
    public bool DeleteDownload(Guid taskId)
    {
        if (_tasks.TryRemove(taskId, out var task))
        {
            // 1. Stop the active download immediately (if running)
            task.CancellationTokenSource?.Cancel();
            task.Status = DownloadStatus.Cancelled;

            try
            {
                // 2. Delete main file (even partial one)
                if (System.IO.File.Exists(task.DestinationFilePath))
                {
                    System.IO.File.Delete(task.DestinationFilePath);
                }

                // 2.1 Delete PARTIAL file (.part)
                if (System.IO.File.Exists(task.PartFilePath))
                {
                    System.IO.File.Delete(task.PartFilePath);
                }

                // 3. Delete .info file
                if (System.IO.File.Exists(task.InfoFilePath))
                {
                    System.IO.File.Delete(task.InfoFilePath);
                }

                // 4. Dispose and clean up task resources
                task.Dispose();
                return true;
            }
            catch (System.Exception)
            {
                // Re-add the task if cleanup failed? Depends on desired behavior. For simplicity, just return false.
                return false;
            }
        }
        return false;
    }

    // *****************************************************************
    // * IDisposable Implementation for Cleanup *
    // *****************************************************************

    /// &lt;summary&gt;
    /// Cancels all active (Downloading or Pending) tasks before cleanup.
    /// &lt;/summary&gt;
    public void CancelAllActiveTasks()
    {
        var activeTasks = _tasks.Values
            .Where(t =&gt; t.Status == DownloadStatus.Downloading || t.Status == DownloadStatus.Pending || t.Status == DownloadStatus.Paused)
            .ToList();

        foreach (var task in activeTasks)
        {
            if (task.Status == DownloadStatus.Downloading || task.Status == DownloadStatus.Paused)
            {
                task.Status = DownloadStatus.Cancelled;
                task.CancellationTokenSource?.Cancel();
            }
            else if (task.Status == DownloadStatus.Pending)
            {
                task.Status = DownloadStatus.Cancelled;
            }
        }
    }

    /// &lt;summary&gt;
    /// Releases the unmanaged and managed resources.
    /// &lt;/summary&gt;
    public void Dispose()
    {
        Dispose(true);
        System.GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            // 1. Cancel all active tasks to free up any running threads/tasks
            CancelAllActiveTasks();

            // 2. Dispose managed resources
            _httpClient.Dispose();
            _concurrencyLimiter.Dispose();

            // 3. Dispose of all DownloadTask instances
            foreach(var task in _tasks.Values)
            {
                task.Dispose();
            }
            _tasks.Clear();
        }

        _disposed = true;
    }
}</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>download-manager</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>7B4D4B9DFF27ADE38B697F7C5DA1852A</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>575</Address>
    <Name>Download Manager</Name>
    <Description>A robust, asynchronous HTTP(S) file transfer service accessible via a dedicated API. It manages the full download lifecycle, supporting pause/resume (using Range headers) and temporary file handling (.part).</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddOption("Email.Sender", "", "1. E-Mail address", "text")
  .AddOption("Email.SmtpServer", "", "2. SMTP Mail Server address", "text")
  .AddOption("Email.SmtpUserName", "", "3. SMTP username (optional)", "text")
  .AddOption("Email.SmtpPassword", "", "4. SMTP password (optional)", "password")
  .AddOption("Email.SmtpPort", "25", "5. SMTP Mail Server port", "text")
  .AddOption("Email.SmtpUseSsl", "false", "6. SMTP Mail Server use SSL", "checkbox")
  .Run();
</ScriptSetup>
    <ScriptSource>// detect when an option of this program is changed and store the new value to system settings
When.ModuleParameterChanged((module, parameter)=&gt;{
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
	var settingName = parameter.Name.Substring(17); // skip "ConfigureOptions." part
    Settings.Parameter("Messaging."+settingName).Value = parameter.Value;
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>e-mail-account</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>D5ED1400F10DBDA875BE6EDCE779EB46</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>142</Address>
    <Name>E-Mail Account</Name>
    <Description>Stores e-mail account info used by system programs for sending/receiving emails.</Description>
    <Group>Messaging and Social</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// Run the program's Main
Program.Run();
</ScriptSetup>
    <ScriptSource>// *************************************************************************
// API HANDLER: Weekly Statistics Request (Daily Aggregation)
// Manages the endpoint for retrieving the available week range and the
// average Watts/Hour statistics aggregated by day of the week.
// Format: /Weekly/Meter.Watts.Hour/[Domain]/[Address]/[WeekNumber | BrowsingRange]
// *************************************************************************
Api.Handle("DataProcessing.Statistics/Weekly/Meter.Watts.Hour", (args) =&gt; {
    var request = Api.Parse(args);
    if (request.Command == "BrowsingRange")
    {
        // return results browsing info
        return GetYearWeekRange();
    }
    ushort weekNumber = 0;
    if (ushort.TryParse(request.Command, out weekNumber))
    {
        // return data for "weekNumber"
        return GetWeeklyStats(request.Domain, request.Address, weekNumber);
    }
    // default to current week
    return GetWeeklyStats(request.Domain, request.Address, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now));
});

// *************************************************************************
// API HANDLER: Hourly Statistics Request (Hourly Aggregation)
// Manages the endpoint for retrieving the available week range and the
// average Watts/Hour statistics aggregated by hour of the day.
// Format: /Hourly/Meter.Watts.Hour/[Domain]/[Address]/[WeekNumber | BrowsingRange]
// *************************************************************************
Api.Handle("DataProcessing.Statistics/Hourly/Meter.Watts.Hour", (args) =&gt; {
    var request = Api.Parse(args);
    if (request.Command == "BrowsingRange")
    {
        // return results browsing info
        return GetYearWeekRange();
    }
    ushort weekNumber = 0;
    if (ushort.TryParse(request.Command, out weekNumber))
    {
        // return data for "weekNumber"
        return GetHourlyStats(request.Domain, request.Address, weekNumber);
    }
    // default to current week
    return GetHourlyStats(request.Domain, request.Address, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now));
});

// *************************************************************************
// REAL-TIME DATA UPDATE PROCESS (Downsampling - Mobile Window)
// Recalculates the average Watts consumption for the LAST HOUR (a mobile 60-minute
// window) and logs this rolling average. The process executes at a fixed 60-second
// interval and does NOT align to clock time.
// *************************************************************************
while (Program.IsRunning)
{

    // Calculates for each module average Watt consumption over the last 60 minutes
    var now = DateTime.UtcNow;
    var monitorModules = Modules.WithFeature("EnergyManagement.MonitorWatts");
    monitorModules.Each((mod) =&gt; {

        double defaultValue = mod.Parameter("Meter.Watts").Statistics.Current.Value;

        // NOTE ON DATA INTEGRITY: The underlying device must emit values
        // (including 0.0 when off) at regular intervals for this average to be accurate.
        var records = mod.Parameter("Meter.Watts").Statistics.History
                .FindAll(sv =&gt; sv.Value &gt;= 0 &amp;&amp; sv.Value &lt;= WATT_VALUE_ERROR_MAX &amp;&amp; (now - sv.Timestamp).TotalSeconds &lt; UpdateInterval);

        var avgWatt = records
            .Select(sv =&gt; sv.Value)
            .DefaultIfEmpty(defaultValue)
            .Average();

        mod.Emit("Meter.Watts.Hour", avgWatt);

        // store to database
        UpdateDatabase(mod.Instance, "Meter.Watts.Hour", avgWatt);

        return false;

    });

    // Update stats every minute
    Pause(60);

}
</ScriptSource>
    <ScriptContext>const int UpdateInterval = 3600; // 1 hour
const string DbTable = "weekly";
const double WATT_VALUE_ERROR_MAX = 7000;

class WeeklyStat {
    [BsonId]
    public Int32 ID { get; set; }
    public string Domain { get; set; }
    public string Address { get; set; }
    public byte DayHour { get; set; }
    public byte WeekDay { get; set; }
    public ushort YearWeek { get; set; }
    public string Parameter { get; set; }
    public double WattsHour { get; set; }

    public WeeklyStat() {}
    public WeeklyStat(string domain, string address, string p, double v, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
    {
        Domain = domain;
        Address = address;
        Parameter = p;
        WattsHour = v;
        YearWeek = weekOfYear;
        WeekDay = dayOfWeek;
        DayHour = hourOfDay;
    }
}

bool UpdateDatabase(Module m, string p, double v)
{
    UpdateWeeklyStat(m.Domain, m.Address, p, v, (ushort)ISOWeek.GetWeekOfYear(DateTime.Now), (byte)DateTime.Now.DayOfWeek, (byte)DateTime.Now.Hour);
    return true;
}

bool UpdateWeeklyStat(string domain, string address, string parameter, double wattsHour, ushort weekOfYear, byte dayOfWeek, byte hourOfDay)
{
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        var record = stats.FindOne(x =&gt;
                        x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.Parameter == parameter
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == dayOfWeek
                        &amp;&amp; x.DayHour == hourOfDay
                    );
        if (record == null)
        {
            stats.Insert(new WeeklyStat(
                domain,
                address,
                parameter,
                wattsHour,
                weekOfYear,
                dayOfWeek,
                hourOfDay
            ));
        }
        else
        {
            record.WattsHour = wattsHour;
            stats.Update(record);
        }
    }
    return true;
}

double[] GetWeeklyStats(string domain, string address, ushort weekOfYear)
{
    var results = new double[7];
    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);
        for (byte i = 0; i &lt; results.Length; i++)
        {
            var sumValues = stats
                .Find(x =&gt; x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.YearWeek == weekOfYear
                        &amp;&amp; x.WeekDay == i);
//                .Sum(x =&gt; x.WattsHour); // &lt;-- this doesn't work with Mono runtime
            double sum = 0;
            foreach(var s in sumValues) {
                sum += s.WattsHour;
            }
            /*    .Select(x =&gt; x.WattsHour)
                  .DefaultIfEmpty(0)
                  .Average();*/
            double avg = sum / 24.0;
            results[i == 0 ? 6 : i - 1] = avg;
        }
    }
    return results;
}

public double[] GetHourlyStats(string domain, string address, ushort targetWeekOfYear)
{
    var results = new double[24];
    ushort weekToFilter = targetWeekOfYear;

    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        stats.EnsureIndex(x =&gt; x.Domain);
        stats.EnsureIndex(x =&gt; x.Address);
        stats.EnsureIndex(x =&gt; x.DayHour);
        stats.EnsureIndex(x =&gt; x.WeekDay);
        stats.EnsureIndex(x =&gt; x.Parameter);

        for (byte i = 0; i &lt; 24; i++) // i = DayHour
        {
            var sumValues = stats
                .Find(x =&gt; x.Domain == domain
                        &amp;&amp; x.Address == address
                        &amp;&amp; x.YearWeek == weekToFilter
                        &amp;&amp; x.DayHour == i);

            double sum = 0;

            foreach(var s in sumValues) {
                sum += s.WattsHour;
            }

            double avg = sum / 7.0;
            results[i] = avg;
        }
    }
    return results;
}

public object GetYearWeekRange()
{
    ushort minYearWeek = ushort.MaxValue;
    ushort maxYearWeek = 0;
    bool foundAny = false;

    lock(this)
    using(var db = Data.LiteDb(GetDbName()))
    {
        var stats = db.GetCollection&lt;WeeklyStat&gt;(DbTable);
        var allStats = stats.FindAll();

        foreach (var stat in allStats)
        {
            ushort currentYearWeek = stat.YearWeek;
            if (!foundAny || currentYearWeek &lt; minYearWeek)
            {
                minYearWeek = currentYearWeek;
            }
            if (!foundAny || currentYearWeek &gt; maxYearWeek)
            {
                maxYearWeek = currentYearWeek;
            }
            foundAny = true;
        }
    }

    if (!foundAny)
    {
        ushort currentWeek = (ushort)ISOWeek.GetWeekOfYear(DateTime.Now);
        return new { WeekStart = currentWeek, WeekEnd = currentWeek };
    }

    return new {
        Start = minYearWeek,
        End = maxYearWeek,
        Count = (maxYearWeek - minYearWeek) + 1,
        Step = 1,
        Base = minYearWeek,
        Current = maxYearWeek,
        Label = "week_of_year"
    };
}

public string[] GetDayLabels()
{
    DayOfWeek[] desiredOrder = new DayOfWeek[]
    {
        DayOfWeek.Monday,    // 0
        DayOfWeek.Tuesday,   // 1
        DayOfWeek.Wednesday, // 2
        DayOfWeek.Thursday,  // 3
        DayOfWeek.Friday,    // 4
        DayOfWeek.Saturday,  // 5
        DayOfWeek.Sunday     // 6
    };
    DateTimeFormatInfo dtfi = CultureInfo.CurrentCulture.DateTimeFormat;
    string[] finalLabels = new string[7];
    for (int i = 0; i &lt; 7; i++)
    {
        DayOfWeek day = desiredOrder[i];
        int labelIndex = (int)day;
        finalLabels[i] = dtfi.AbbreviatedDayNames[labelIndex];
    }
    return finalLabels;
}

string GetDbName()
{
    return $"energy_use_{DateTime.Now.Year}.db";
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>energy-use-statistics</Id>
      <Version>1.0.9</Version>
      <Required>false</Required>
      <Checksum>A57965D0B4E782C5ED2B01C6230982B7</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>571</Address>
    <Name>Energy Use Statistics</Name>
    <Description>Continuously monitors, aggregates, and logs energy consumption data (Wh) at regular intervals. Implements a full API for browsing and querying historical datasets.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program
    .AddFeature("", "", EventsLoggingFeature, "Enable events logging", "checkbox")
    .Implements("@Statistics:Storage", EventsLoggingDomain, new {
      icon = "database",
      description = "events_logger_database"
    });
});
Program.Run();
</ScriptSetup>
    <ScriptSource>var loggableModules = Modules.WithFeature(EventsLoggingFeature);

When.ProgramStopping(() =&gt; {
//  db.Dispose();
  return true;
});

When.ModuleParameterChanged((mod, p) =&gt; {
  var m = mod.Get().Instance;
  if (loggableModules.SelectedModules.Contains(m)) {
    lock(mod.Get().Instance)
    using (var db = Data.LiteDb(m.Domain+"@"+m.Address+"-events-log")) {
      var data = new LoggerEvent(m, p);
      try {
        db.Pragma("LIMIT_SIZE", LIMIT_SIZE);
        InsertData(db, data);
      } catch (Exception e) {
        // DB is full, delete some data
        var colCheck = db.GetCollection&lt;LoggerEvent&gt;("events");
        long totalCount = colCheck.LongCount();
        if (totalCount &lt;= MAX_RECORDS_TO_KEEP)
        {
            return true;
        }

        int recordsToSkip = (int)totalCount - MAX_RECORDS_TO_KEEP;
        var limitRecord = colCheck.Query()
            .OrderByDescending(x =&gt; x.UnixTimestamp)
            .Skip(recordsToSkip)
            .Limit(1)
            .SingleOrDefault();
        if (limitRecord != null)
        {
            ObjectId thresholdId = limitRecord.Id;
            int deletedCount = colCheck.DeleteMany(x =&gt; x.Id &lt;= thresholdId);
        }
        /*
        try {
          db.Rebuild();
        } catch (Exception ex) {
          Program.Log.Error(ex);
        }
        */
        // Retry insert
        InsertData(db, data);
      }
    }
  }
  return true;
});

Api.Handle(EventsLoggingDomain, (args) =&gt; {
  var cmd = Api.Parse(args);
  var moduleDomain = cmd.Address;
  var moduleAddress = cmd.Command;
  var module = Modules.InDomain(moduleDomain).WithAddress(moduleAddress);
  var parameter = cmd.GetOption(0);

  if(cmd.GetOption(1) == "TimeRange")
  {
    lock(module.Get().Instance)
    using (var db = Data.LiteDb(moduleDomain+"@"+moduleAddress+"-events-log")) {
      var col = db.GetCollection&lt;LoggerEvent&gt;("events");
      var allResults = col.Query()
          .Where(x =&gt; x.Parameter == parameter)
          .Select(x =&gt; x.UnixTimestamp)
          .ToList();
      if (allResults.Any()) {
            long min = allResults.Min();
            long max = allResults.Max();
            return new { Start = min, End = max, Count = allResults.Count };
      }
      return new { Start = 0L, End = 0L, Count = 0L };
    }
  }

  long? startDateMs = GetUnixMs(cmd.GetOption(1));
  long? endDateMs = GetUnixMs(cmd.GetOption(2));

  int limitRows = -1;
  if (!String.IsNullOrEmpty(cmd.GetOption(3)))
  {
    int.TryParse(cmd.GetOption(3), out limitRows);
  }

  int pageNumber = 1;
  int.TryParse(cmd.GetOption(4), out pageNumber);
  if (pageNumber &lt; 1) pageNumber = 1;

  int skipRows = (pageNumber - 1) * limitRows;

  lock(module.Get().Instance)
  using (var db = Data.LiteDb(moduleDomain+"@"+moduleAddress+"-events-log")) {
    var col = db.GetCollection&lt;LoggerEvent&gt;("events");
    var query = col.Query()
      .Where(x =&gt; x.Parameter == parameter);

    if (startDateMs.HasValue &amp;&amp; startDateMs.Value != 0) {
        query = query.Where(x =&gt; x.UnixTimestamp &gt;= startDateMs.Value);
    }
    if (endDateMs.HasValue &amp;&amp; endDateMs.Value != 0) {
        query = query.Where(x =&gt; x.UnixTimestamp &lt;= endDateMs.Value);
    }

    List&lt;LoggerEvent&gt; results;
    if (limitRows &gt; 0)
    {
      results = query
        .OrderByDescending(x =&gt; x.UnixTimestamp)
        .Skip(skipRows).Limit(limitRows)
        .ToList();
    } else {
    	results = query
        .OrderByDescending(x =&gt; x.UnixTimestamp)
        .ToList();
    }
    return results;
  }
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string EventsLoggingFeature = "EventsLogger.EnableLogging";
const string EventsLoggingDomain = "HomeGenie.EventsLogger";

const int LIMIT_SIZE = 2097152;
const int MAX_RECORDS_TO_KEEP = 100;

long? GetUnixMs(string unixMsString) {
    if (long.TryParse(unixMsString, out long unixTimestampMs)) {
        return unixTimestampMs;
    }
    return null;
}

void InsertData(LiteDatabase db, LoggerEvent data) {
    var col = db.GetCollection&lt;LoggerEvent&gt;("events");
    col.EnsureIndex(x =&gt; x.Parameter);
    col.EnsureIndex(x =&gt; x.UnixTimestamp);
    col.Insert(data);
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>events-logging</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>88F75AD3C5A8957108BF8C649D7A8A00</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>95</Address>
    <Name>Events logging</Name>
    <Description>Records device activity.</Description>
    <Group>Security</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes />
        <Property>EventsLogger.EnableLogging</Property>
        <Description>Enable events logging</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Run();</ScriptSetup>
    <ScriptSource>Api.Handle("HomeAutomation.HomeGenie/FileManager", (args) =&gt; {

    var request = Api.Parse(args);

    string basePath = Path.Combine(Data.GetFolder(), "..");
    string relativeFilePath = request.GetOption(0);

    string responseData = "";
    bool success = true;

    try
    {
        if (string.IsNullOrWhiteSpace(relativeFilePath))
            throw new ArgumentException("Missing relative file path (Option 0) in the request.");

        switch(request.Command) {

            case "Write":
                if (request.Data == null) throw new ArgumentException("Missing content data (request.Data) in the request.");

                FileManagerLogic.WriteFile(basePath, relativeFilePath, (byte[])request.Data);

                responseData = $"File '{relativeFilePath}' successfully written.";
                break;

            case "WriteText":
                if (request.Data is byte[] rawBytes)
                {
                    string contentString = Encoding.UTF8.GetString(rawBytes);
                    FileManagerLogic.WriteFileAsString(basePath, relativeFilePath, contentString);

                    responseData = $"Text file '{relativeFilePath}' successfully written.";
                }
                else
                {
                    throw new ArgumentException("WriteText requires a valid string or byte[] content in the request data.");
                }
                break;

            case "Read":
                byte[] fileContent = FileManagerLogic.ReadFile(basePath, relativeFilePath);

                return fileContent;
                break;

            case "ReadText":
                 string fileStringContent = FileManagerLogic.ReadFileAsString(basePath, relativeFilePath);

                return fileStringContent;
                break;

            default:
                success = false;
                responseData = $"Unknown command: {request.Command}";
                break;
        }
    }
    catch (Exception ex)
    {
        success = false;
        responseData = ex.Message;
    }

    return new ResponseStatus(success ? Status.Ok : Status.Error, responseData);
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>public static class FileManagerLogic
{
    private static string GetSafeFullPath(string basePath, string relativeFilePath)
    {
        if (string.IsNullOrWhiteSpace(basePath))
            throw new ArgumentException("Base path cannot be null or empty.", nameof(basePath));

        if (string.IsNullOrWhiteSpace(relativeFilePath))
            throw new ArgumentException("Relative file path cannot be null or empty.", nameof(relativeFilePath));

        string normalizedFullPath = Path.GetFullPath(relativeFilePath);
        string normalizedBasePath = Path.GetFullPath(basePath);

        if (!normalizedFullPath.StartsWith(normalizedBasePath, StringComparison.OrdinalIgnoreCase))
        {
             throw new UnauthorizedAccessException($"Access denied. Path traversal detected. File must be within: {normalizedBasePath}");
        }

        string? directoryPath = Path.GetDirectoryName(normalizedFullPath);
        if (directoryPath != null &amp;&amp; !Directory.Exists(directoryPath))
        {
            Directory.CreateDirectory(directoryPath);
        }

        return normalizedFullPath;
    }

    public static void WriteFile(string basePath, string relativeFilePath, byte[] contentBytes)
    {
        string fullPath = GetSafeFullPath(basePath, relativeFilePath);
        File.WriteAllBytes(fullPath, contentBytes);
    }

    public static byte[] ReadFile(string basePath, string relativeFilePath)
    {
        string fullPath = GetSafeFullPath(basePath, relativeFilePath);
        if (!File.Exists(fullPath))
        {
             throw new FileNotFoundException($"The file was not found at '{fullPath}'.");
        }
        return File.ReadAllBytes(fullPath);
    }

    public static void WriteFileAsString(string basePath, string relativeFilePath, string contentString)
    {
        byte[] contentBytes = Encoding.UTF8.GetBytes(contentString);
        WriteFile(basePath, relativeFilePath, contentBytes);
    }

    public static string ReadFileAsString(string basePath, string relativeFilePath)
    {
        byte[] fileBytes = ReadFile(basePath, relativeFilePath);
        return Encoding.UTF8.GetString(fileBytes);
    }
}</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>file-manager</Id>
      <Version>1.0.0</Version>
      <Required>true</Required>
      <Checksum>45A509656A53CC9D1A38F8301A04FCD6</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>576</Address>
    <Name>File Manager</Name>
    <Description>A secure, API-driven service for reading and writing files within the program's base data folder. It supports both raw binary and UTF-8 string content via dedicated ReadText and WriteText commands.</Description>
    <Group>Utilities</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements(
    "@Statistics:Provider",
    apiUrl,
    new {
        mode = "select_module",
        field = "Meter.Watts.Hour",
        type = "bar",
        title = "W/h",
        icon = "energy_program_time_used"
    }
).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = apiDataUrl,
        scale = "linear",
        labels = GetHourLabels(),
        refreshMs = 60000, // 1 minute
        browsing = true
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/HourlyStats";
const string apiDataUrl = "DataProcessing.Statistics/Hourly/Meter.Watts.Hour";

public string[] GetHourLabels()
{
    var hourLabels = new List&lt;string&gt;(24);
    for (int hour = 0; hour &lt; 24; hour++)
    {
        string label = $"{hour:D2}h";
        hourLabels.Add(label);
    }
    return hourLabels.ToArray();
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>hourly-energy-use-chart</Id>
      <Version>1.0.0</Version>
      <Required>false</Required>
      <Checksum>E14C3C92075902D2C770A9290C8AC110</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>574</Address>
    <Name>Hourly Energy Consumption</Name>
    <Description>Bar chart displaying the average Watts/Hour consumption for every hour of the day (00h-23h). Data is aggregated over the selected week and sourced from the Energy Use Statistics API.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>true</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {
  Program
    .AddOption("ClientId", Program.SystemId, "0. Unique ID for this client", "text")
    .AddOption("ServerAddress", "", "1. MQTT server address", "text")
    .AddOption("ServerPort", "1883", "2. MQTT server port", "text")
    .AddOption("Encryption", "", "3. End-to-end message encryption (E2EE)", "checkbox")
    .AddOption("EncryptionKey", "", "Encryption key", "hidden")
    .AddOption("WebSockets", "", "4. Use WebSockets", "checkbox")
    .AddOption("TLS", "", "5. Enable TLS/SSL", "checkbox")
    .AddOption("Username", "", "6. Username (optional)", "text")
    .AddOption("Password", "", "7. Password (optional)", "text")
    .AddOption("ImportExternal", "", "8. Import external modules", "checkbox");
});

encryptionKey = Program.Option("EncryptionKey").Value;

Program.Run();
</ScriptSetup>
    <ScriptSource>string server = Program.Option("ServerAddress").Value.Trim();
int port = 1883; int.TryParse(Program.Option("ServerPort").Value, out port);
string clientid = Program.Option("ClientId").Value.Trim();
string username = Program.Option("Username").Value.Trim();
string password = Program.Option("Password").Value.Trim();
bool useWebSockets = Program.Option("WebSockets").Value == "On";
bool useTls = Program.Option("TLS").Value == "On";
bool enableEncryption = Program.Option("Encryption").Value == "On";
bool importExternal = Program.Option("ImportExternal").Value == "On";
if (importExternal) {
  Program.Option("Encryption").Value = "";
  enableEncryption = false;
}

var ResponseList = new Dictionary&lt;String, object&gt;();

var MqttIsConnected = false;
MqttClient.Reset();
Program.Emit("MQTT.Status", "configure");

// key used for encryption
byte[] key = Encoding.UTF8.GetBytes(Program.SystemId);

string subscribeTopic = clientid + "/#";
if (enableEncryption) {
  subscribeTopic = encryptTopic(clientid, key) + "/#";
}
if (importExternal) {
  subscribeTopic = "#";
} else {
  // export MQTT-published modules
  Program.AddFeature("", "", "MQTT.SensorPublish", "Publish events emitted by this module", "checkbox");
}

Action&lt;string, string, byte[]&gt; publishBytes = (string cid, string topic, byte[] payload) =&gt; {
  if (enableEncryption) {
    topic = encryptTopic(cid, key) + "/" + encryptTopic(topic, key);
    payload = encryptionFilter(payload, key);
  } else {
    topic = cid + "/" + topic;
  }
  MqttClient.Publish(topic, payload);
};

Action&lt;string, string, string&gt; publish = (string cid, string topic, string message) =&gt; {
  publishBytes(cid, topic, Encoding.UTF8.GetBytes(message));
};

Action&lt;string&gt; apiHandle = (string cid) =&gt; {
  Api.Handle("MQTT:" + cid, ( args ) =&gt; {
    var request = Api.Parse(args);
    var domain = request.Domain;
    var address = request.Address;
    string command = $"{request.Command}/{request.OptionsString}";
    try
    {
      int mqttend = domain.IndexOf(".");
      int mqttdel = domain.IndexOf(":");
      var mqttdest  = domain.Substring(mqttdel + 1, mqttend - mqttdel - 1);
      var mqttsrc = Program.SystemId;
      domain = domain.Substring(mqttend + 1);
      // send request
      var cmd = new MqttCommand(mqttsrc, domain + "/" + address + "/" + command, request.Data);
      var tid = cmd.TransactionId;
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(cmd));
      string payload = Encoding.UTF8.GetString(bytes);
      publish(clientid, "MQTT.Listeners/" + mqttdest + "/command", payload);
      // wait for response
      var res = new ResponseText("ERROR");
      lock (operationLock) ResponseList.Add(tid, res);
      SpinWait.SpinUntil(() =&gt; {
        bool notReady = true;
        try {
          notReady = ResponseList[tid] != res;
        } catch {}
        return notReady;
      }, 10000);
      var response = ResponseList[tid];
      lock (operationLock) ResponseList.Remove(tid);
      return response;
    } catch (Exception e) {
      Program.Notify($"ERROR #2: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
    return new ResponseText("ERROR");
  });
  Api.Handle("HomeAutomation.HomeGenie/Config/Modules.UpdateInfo/MQTT:" + cid, ( args ) =&gt; {
    var request = Api.Parse(args);
    var domain = request.GetOption(0);
    var address = request.GetOption(1);
    try
    {
      int mqttend = domain.IndexOf(".");
      int mqttdel = domain.IndexOf(":");
      var mqttdest  = domain.Substring(mqttdel + 1, mqttend - mqttdel - 1);
      var mqttsrc = Program.SystemId;
      domain = domain.Substring(mqttend + 1);
      string command = $"{request.Domain}/{request.Address}/{request.Command}/{domain}/{address}";
      string jsonPayload = System.Text.Encoding.UTF8.GetString((System.Byte[])request.Data);
      // send request
      var cmd = new MqttCommand(mqttsrc, command, jsonPayload);
      var tid = cmd.TransactionId;
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(cmd));
      string payload = Encoding.UTF8.GetString(bytes);
      publish(clientid, "MQTT.Listeners/" + mqttdest + "/command", payload);
      // wait for response
      var res = new ResponseText("ERROR");
      ResponseList.Add(tid, res);
      SpinWait.SpinUntil(() =&gt; ResponseList[tid] != res, 10000);
      var response = ResponseList[tid];
      ResponseList.Remove(tid);
      return response;
    }
    catch (Exception e)
    {
      Program.Notify($"ERROR #3: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
    return new ResponseText("ERROR");
  });
};

MqttClient.Subscribe(subscribeTopic, (mtopic, bytespayload) =&gt; {
  var parts = mtopic.Split('/');
  var cid = parts[0];
  if (parts.Length == 2) { // encrypted topic
    cid = decryptTopic(cid, key);
    mtopic = decryptTopic(parts[1], key);
    mtopic = cid + "/" + mtopic;
    parts = mtopic.Split('/');
    bytespayload = encryptionFilter(bytespayload, key);
  }
  if (parts.Length == 4)
  {
    try
    {
      var domain = parts[1];
      var address = parts[2];
      var type = parts[3];
      // convert binary message to string
      string mpayload = Encoding.UTF8.GetString(bytespayload);

      var module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();

      switch (type)
      {
        case "command":
        if (domain == "MQTT.Listeners" &amp;&amp; address == clientid)
        {
          var cmdobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
          var targetmodule = Modules.InDomain(cmdobj.Domain.ToString()).WithAddress(cmdobj.Address.ToString());
          if (targetmodule.Get().Instance != null)
          {
            string command = cmdobj.Command.ToString();
            switch (command)
            {
              case "Module.Describe":
              var modinstance = targetmodule.Get().Instance;
              publish(clientid, modinstance.Domain + "/" + modinstance.Address + "/description", Service.Utility.Module2Json(modinstance, false));
              break;
              default:
              var m = targetmodule.Get().Instance;
              var apiCommand = m.Domain + "/" + m.Address + "/" + command;
              var result = Api.Call(apiCommand, cmdobj.Data);
              try {
                result = (byte[])result;
                publishBytes(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", (byte[])result);
              } catch (Exception e) {
                publish(cid, clientid + "/" + cmdobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
              }
              break;
            }
          }
        }
        break;

        case "request":
        var reqobj = JsonConvert.DeserializeObject&lt;dynamic&gt;(mpayload);
        try {
          var result = Api.Call(reqobj.Request.ToString(), reqobj.Data);
          // send response with result
          //if (result != "null") {
            try {
              result = (byte[])result;
              publishBytes(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", (byte[])result);
            } catch (Exception e) {
              publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
            }
          //} else {
          //  publish(cid, clientid + "/" + reqobj.TransactionId.ToString() + "/response", JsonConvert.SerializeObject(result));
          //}
        } catch (Exception e) {
          Program.Notify(e.Message);
        }
        break;

        case "description":
        if (cid != clientid &amp;&amp; module.Instance != null)
        {
          var modobj = JsonConvert.DeserializeObject&lt;Module&gt;(mpayload);
          module.Instance.Name = modobj.Name;
          module.Instance.Description = modobj.Description;
          module.Instance.DeviceType = modobj.DeviceType;
          var parentid = module.Parameter("VirtualModule.ParentId").Value;
          module.Instance.Properties = modobj.Properties;
          module.Parameter("VirtualModule.ParentId").Value = parentid;
          module.Parameter("MQTT.SourceNode").Value = cid;
          //Program.Notify("Imported remote module " + module.Instance.Domain + " " + module.Instance.Address);
        }
        break;

        case "event":
        if (cid != clientid &amp;&amp; importExternal)
        {
          var property = JsonConvert.DeserializeObject&lt;ModuleParameter&gt;(mpayload);
          if (module.Instance == null)
          {
            Program.AddModule("MQTT:" + cid + "." + domain, address, "Sensor", "");
            module = Modules.InDomain("MQTT:" + cid + "." + domain).WithAddress(address).Get();
            apiHandle(cid);
          }
          else if (!module.HasParameter("MQTT.SourceNode"))
          {
            publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + domain + "', 'Address' : '" + address + "', 'Command' : 'Module.Describe' }");
          }
          module.Emit(property.Name, property.Value);
        }
        break;

        case "response":
        if (cid == clientid)
        {
          var tid = address;
          var responseBody = mpayload;
          if (ResponseList.ContainsKey(tid))
          {
              ResponseList[tid] = bytespayload;
          }
        }
        break;
      }
    } catch (Exception e) {
      Program.Notify($"ERROR #1: {e.Message} {OptionButtons}");
      Pause(2);
      MqttIsConnected = false;
    }
  }
});

When.ModuleParameterChanged( (module, property) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; property.Name.StartsWith("ConfigureOptions.")) {
    if (Program.IsRunning) Program.Restart();
    return true;
  }
  if (!importExternal &amp;&amp; module.HasFeature("MQTT.SensorPublish") &amp;&amp; !module.Instance.Domain.StartsWith("MQTT:"))
  {
    try{
      byte[] bytes = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(property));
      publishBytes(clientid, module.Instance.Domain + "/" + module.Instance.Address + "/event", bytes);
    } catch  (Exception e){
      //Program.Notify($"ERROR: {e.Message} {OptionButtons}");
      MqttIsConnected = false;
    }
  }
  // returning true, will route event to other listeners
  return true;
});

// Validate configuration

if (String.IsNullOrEmpty(clientid))
{
  clientid = Program.Option("ClientId").Value = Program.SystemId;
}
if (String.IsNullOrEmpty(server))
{
  Program.Notify($"MQTT endpoint is not configured. {OptionButtons}");
  Pause(5);
  return;
}

Action&lt;string&gt; importModules = (string serverAddress) =&gt; {
  try {
    var domain = "HomeAutomation.HomeGenie";
    var data = Net
      .WebService($"http://{serverAddress}/api/{domain}/Config/Modules.List")
      .GetData();
    List&lt;Module&gt; modules = JsonConvert.DeserializeObject&lt;List&lt;Module&gt;&gt;(data.ToString());
    var mini = modules.Find(md =&gt; md.Domain == domain &amp;&amp; (md.Address == "mini" || md.Address == "system"));
    var systemInfo = mini.Properties.Find(p =&gt; p.Name == "System.Info");
    dynamic info = JsonConvert.DeserializeObject(systemInfo.Value);
    string cid = info.Id;
    apiHandle(cid);
    foreach (var m in modules) {
      string type = m.DeviceType.ToString();
      if (type == "Program") continue;
      Program.AddModule("MQTT:" + cid + "." + m.Domain, m.Address, type, "");
      publish(clientid, "MQTT.Listeners/" + cid + "/command", "{ 'Domain': " + "'" + m.Domain + "', 'Address' : '" + m.Address + "', 'Command' : 'Module.Describe' }");
    }
  } catch (Exception e) {
    Program.Notify($"{e.Message}");
  }
};
if (!importExternal)
{
  apiHandle("");
}

while (Program.IsRunning) {

  // Connect to MQTT

  if (!MqttIsConnected) {
    MqttIsConnected = true;
    Program.Notify("Connecting to '" + server + ":" + port + "' ...");
    Program.Emit("MQTT.Status", "connecting");
    try
    {
      if (username != "")
      {
        MqttClient.WithCredentials(username, password);
      }

      MqttClient
        .Service(server)
        .UsingWebSockets(useWebSockets)
        .WithTls(useTls)
        .Connect(port, Guid.NewGuid().ToString(), (connected)=&gt; {
          MqttIsConnected = connected;
          if (connected) {
              Program.Notify("Connected!");
              Program.Emit("MQTT.Status", "connected");
              if (importExternal)
              {
                importModules(server);
              }
          } else {
              Program.Notify("Disconnected!");
              Program.Emit("MQTT.Status", "disconnected");
          }
        });
    }
    catch (Exception e)
    {
      Program.Notify($"{e.Message} {OptionButtons}");
      Pause(5);
      return;
    }
  }

  Pause(30);

}
</ScriptSource>
    <ScriptContext>const string OptionButtons = "[program_configure,program_disable]";
static string encryptionKey = "";
static object operationLock = new object();

static string encryptTopic(string topic, byte[] clientKey) {
    byte[] t = Encoding.UTF8.GetBytes(topic);
    t = encryptionFilter(t, clientKey);

    string encryptedTopic = Convert.ToBase64String(t);
    encryptedTopic = encryptedTopic.Replace("/", "%");
    encryptedTopic = encryptedTopic.Replace("+", "&amp;");

    return encryptedTopic;
}

static string decryptTopic(string topic, byte[] clientKey) {
    topic = topic.Replace("%", "/");
    topic = topic.Replace("&amp;", "+");
    byte[] encryptedTopic = Convert.FromBase64String(topic);
    return Encoding.UTF8.GetString(encryptionFilter(encryptedTopic, clientKey));
}

static byte[] encryptionFilter(byte[] payload, byte[] clientKey) {
    if (!String.IsNullOrEmpty(encryptionKey)) {
        byte[] output = new byte[256];
        byte[] k = Convert.FromBase64String(encryptionKey);
        k = andFilter(k, clientKey);
        payload = xorFilter(payload, k);
    }
    return payload;
}

static byte[] xorFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k ^ i);
            payload[c] = o;
        }
    }
    return payload;
}

static byte[] andFilter(byte[] payload, byte[] clientKey) {
    if (clientKey.Length &gt; 0) {
        for (int c = 0; c &lt; payload.Length; c++) {
            byte k = clientKey[c % clientKey.Length];
            byte i = payload[c];
            byte o = (byte)(k &amp; i);
            payload[c] = o;
        }
    }
    return payload;
}

class MqttCommand: MigInterfaceCommand {
    public MqttCommand(string cid, string request, object data): base(request, data) {
        ClientId = cid;
        TransactionId = Guid.NewGuid().ToString();
    }
    public string ClientId {get; set;} = "";
    public string TransactionId {get; set;} = "";
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>mqtt-network</Id>
      <Version>1.0.9</Version>
      <Required>true</Required>
      <Checksum>8C0D66916C7D8071C71AA2527BE73D97</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>77</Address>
    <Name>MQTT Network</Name>
    <Description>Connect to an MQTT broker to use HomeGenie Panel app from anywhere via Internet or to interconnect HomeGenie devices on the same MQTT network.</Description>
    <Group>Interconnections</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>true</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>false</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// list the program as custom weather widget
Program.UseWidget( "homegenie/environment/weather" )
  // set input fields parameters
  // &lt;field_name&gt;, &lt;default_value&gt;, &lt;description&gt;
  .AddOption("Location", "London, UK", "City name", "wunderground.city")
  .AddOption("Language", "EN", "Language", "text")
  .AddOption("ApiKey", "?", "OpenWeatherMap API key (APPID)", "text")
  .AddOption("UpdateInterval", "30", "Update interval (minutes)", "slider:15:1440:15:15");

// initialize widget program parameters
Program.Parameter("Astronomy.Sunset").Value = "";
Program.Parameter("Astronomy.Sunrise").Value = "";
Program.Parameter("Conditions.City").Value = "";
Program.Parameter("Conditions.DisplayLocation").Value = "";
Program.Parameter("Conditions.IconType").Value = "";
Program.Parameter("Conditions.Description").Value = "";
Program.Parameter("Sensor.Temperature").Value = "22.44";

Program.Parameter("EventsLogger.EnableLogging").Value = "On";
Program.Run();
</ScriptSetup>
    <ScriptSource>Action&lt;dynamic&gt; UpdateWeatherParameters = (data) =&gt; {
  Program
    .Emit("Conditions.City", data.city)
    .Emit("Conditions.DisplayLocation", data.city)
    .Emit("Conditions.Country", data.country)
    .Emit("Conditions.Description", data.weather_description)
    .Emit("Conditions.IconType", data.weather_icon)
    .Emit("Conditions.Status", data.weather_status) // eg. cloudy, sunny, etc..
    .Emit("Conditions.LastUpdated", data.update_dt)
    .Emit("Conditions.Timestamp", data.timestamp)
    // Add values to standard Sensor.* parameters
    .Emit("Sensor.Temperature", data.temperature)
    .Emit("Sensor.Temperature.Unit", "Celsius")
    .Emit("Sensor.Pressure", data.pressure)
    .Emit("Sensor.Pressure.Unit", "Mb")
    .Emit("Sensor.Wind.Speed", data.wind_speed)
    .Emit("Sensor.Wind.Speed.Unit", "Kph")
    .Emit("Sensor.Wind.Direction", data.wind_direction)
    .Emit("Sensor.Precipitation.Rain", data.rain_1h_mm)
    .Emit("Sensor.Precipitation.Rain.Unit", "1h")
    .Emit("Sensor.Precipitation.Snow", data.snow_1h_mm)
    .Emit("Sensor.Precipitation.Snow.Unit", "1h");
  // TODO: Program.Parameter("Sensor.UV").Value = "...";
};
Action&lt;int,dynamic&gt; UpdateForecastParameters = (day, data) =&gt; {
  Program
    .Emit("Conditions.Forecast." + day + ".Description", data.weather_description)
    .Emit("Conditions.Forecast." + day + ".Year", data.dt.ToString("yyyy"))
    .Emit("Conditions.Forecast." + day + ".Month", data.dt.ToString("MMM"))
    .Emit("Conditions.Forecast." + day + ".Day", data.dt.ToString("dd"))
    .Emit("Conditions.Forecast." + day + ".Timestamp", data.timestamp)
    .Emit("Conditions.Forecast." + day + ".Weekday", data.dt.ToString("dddd"))
    .Emit("Conditions.Forecast." + day + ".IconType", data.weather_icon)
    .Emit("Conditions.Forecast." + day + ".Temperature", data.temperature)
    .Emit("Conditions.Forecast." + day + ".Temperature.Min", data.temperature_min)
    .Emit("Conditions.Forecast." + day + ".Temperature.Max", data.temperature_max);
};
Func&lt;string,string&gt; GetWeatherIcon = (type) =&gt; {
  var icon = type;
  switch(type)
  {
    case "clear": // 	clear sky
      icon = "01d";
      break;
    case "partlycloudy": // 	few clouds
      icon = "02d";
      break;
    case "scatteredclouds": // scattered clouds
      icon = "03d";
      break;
    case "cloudy": // broken clouds (?)
      icon = "04d";
      break;
    case "showerrain": // 	shower rain
      icon = "09d";
      break;
    case "rain": // rain
      icon = "10d";
      break;
    case "thunderstorms": // thunderstorms
      icon = "11d";
      break;
    case "snow": // snow
      icon = "13d";
      break;
    case "hazy": // mist
      icon = "50d";
      break;
    // Night icons
    case "clear_night": // 	clear sky
      icon = "01n";
      break;
    case "partlycloudy_night": // 	few clouds
      icon = "02n";
      break;
    case "scatteredclouds_night": // scattered clouds
      icon = "03n";
      break;
    case "cloudy_night": // broken clouds (?)
      icon = "04n";
      break;
    case "showerrain_night": // 	shower rain
      icon = "09n";
      break;
    case "rain_night": // rain
      icon = "10n";
      break;
    case "thunderstorms_night": // thunderstorms
      icon = "11n";
      break;
    case "snow_night": // snow
      icon = "13n";
      break;
    case "hazy_night": // mist
      icon = "50n";
      break;
  }
  return icon;
};
Func&lt;dynamic, dynamic&gt; CollectWeatherData = (weatherData) =&gt; {
  dynamic data = new ExpandoObject();
  data.timestamp = 1000D*(int)weatherData.dt;
  data.dt = Utility.JavaTimeStampToDateTime(data.timestamp);
  data.update_dt = data.dt.ToLongDateString() + " " + TimeZoneInfo.ConvertTime(data.dt, TimeZoneInfo.Local).ToLongTimeString();
  data.temperature = weatherData.main.temp.ToString();
  data.temperature_min = weatherData.main.temp_min.ToString();
  data.temperature_max = weatherData.main.temp_max.ToString();
  data.pressure = weatherData.main.pressure.ToString();
  var rain_1h_mm = "0";
  var rain_3h_mm = "0";
  if (weatherData.rain != null) {
    if (weatherData.rain["1h"] != null)
      rain_1h_mm = weatherData.rain["1h"].ToString();
    if (weatherData.rain["3h"] != null)
      rain_3h_mm = weatherData.rain["3h"].ToString();
  }
  data.rain_1h_mm = rain_1h_mm;
  var snow_1h_mm = "0";
  var snow_3h_mm = "0";
  if (weatherData.snow != null) {
    if (weatherData.snow["1h"] != null)
      snow_1h_mm = weatherData.snow["1h"].ToString();
    if (weatherData.snow["3h"] != null)
      snow_3h_mm = weatherData.snow["3h"].ToString();
  }
  data.snow_1h_mm = snow_1h_mm;
  data.wind_speed = weatherData.wind.speed.ToString();
  data.wind_direction = "";
  if (weatherData.wind.deg != null)
  	data.wind_direction = weatherData.wind.deg.ToString();
  data.weather_status = weatherData.weather[0].main.ToString();
  data.weather_description = weatherData.weather[0].description.ToString();
  data.weather_icon = GetWeatherIcon(weatherData.weather[0].icon.ToString());
  // city and country fields are not present in forecast data
  if (weatherData.name != null)
  	data.city = weatherData.name.ToString();
  if (weatherData.sys != null &amp;&amp; weatherData.sys.country != null)
  	data.country = weatherData.sys.country.ToString();
  return data;
};

bool reconfigureRequired = false;
When.ModuleParameterChanged((module, parameter) =&gt; {
  if (module.Instance == Program.Module &amp;&amp; parameter.Name.StartsWith("ConfigureOptions.")) {
    reconfigureRequired = true;
  }
  return true;
});

while (Program.IsRunning)
{
  string location = Program.Option("Location").Value;
  string language = Program.Option("Language").Value;
  string apikey = Program.Option("ApiKey").Value.Trim();

  if (!apikey.Contains("?") &amp;&amp; apikey.Length &gt; 0)
  {
    try
    {
      string webserviceurl = "https://api.openweathermap.org/data/2.5/weather?q=" + location + "&amp;lang=" + language + "&amp;units=metric&amp;appid=" + apikey;
      var weatherData = Net.WebService(webserviceurl).GetData();

      var sunset = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunset);
      var sunrise = Utility.JavaTimeStampToDateTime(1000D*(int)weatherData.sys.sunrise);

      Program.Emit("Astronomy.Sunset", TimeZoneInfo.ConvertTime(sunset, TimeZoneInfo.Local).ToShortTimeString());
      Program.Emit("Astronomy.Sunrise", TimeZoneInfo.ConvertTime(sunrise, TimeZoneInfo.Local).ToShortTimeString());

      var data = CollectWeatherData(weatherData);
      UpdateWeatherParameters(data);

      // get forecast data
	  webserviceurl = "https://api.openweathermap.org/data/2.5/forecast?q=" + location + "&amp;lang="+language+"&amp;units=metric&amp;appid=" + apikey;
      var forecast = Net.WebService(webserviceurl).GetData();

      var forecastDay = 1;
      var nextDay = DateTime.UtcNow.AddDays(1); nextDay = nextDay.Date + new TimeSpan(12, 0, 0);
      foreach(var fc in forecast.list)
      {
        var forecastTime = Utility.JavaTimeStampToDateTime(1000D*(int)fc.dt);
        if (forecastTime.Equals(nextDay)) {
          // collect forecast data for current forecastDay

          var forecastData = CollectWeatherData(fc);
          UpdateForecastParameters(forecastDay, forecastData);

          nextDay = nextDay.AddDays(1);
          forecastDay++;
        }
        // process up to 3 days
        if (forecastDay &gt; 3) break;
      }
      //Program.Emit("Program.UiRefresh", "Data Updated");

    }
    catch (Exception e)
    {

      Program.Notify("ERROR: unable to get data from service. " + e.Message);
      Console.WriteLine( e.Message );
      Pause(10);

    }
  }
  //
  var delayMins = Program.Option("UpdateInterval").DecimalValue;
  if (delayMins &lt; 1) delayMins = 1;
  double pauseBeforeNextUpdate = delayMins*60; // seconds
  while (pauseBeforeNextUpdate-- &gt; 0 &amp;&amp; !reconfigureRequired) {
	  Pause(1);
  }
  reconfigureRequired = false;
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>openweathermap</Id>
      <Version>1.0.3</Version>
      <Required>true</Required>
      <Checksum>44F31757B7D56F8ABBA651989A14CFFB</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>34</Address>
    <Name>OpenWeatherMap</Name>
    <Description>Weather and forecast information from Open Weather Map service.
To activate this widget enter a valid API key.
Follow instructions at https://openweathermap.org/appid to get a free API key.
</Description>
    <Group>Weather and Environment</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>// This method is used to register this program as a Chart provider
Program.Implements(
    "@Statistics:Provider",
    apiUrl,
     // the following param's value can be:
     // --&gt; "select_module", "select_property" or "select_none"
    new {
        mode = "select_none",
        legend = true,
        icon = "pie_chart"
    }
).Run();
</ScriptSetup>
    <ScriptSource>// This API method will be called by the chart component
// to get the configuration of the chart to generate
Api.Handle(apiUrl, (args) =&gt; {
    return new {
        // API url to call to get updated chart data from this program
        dataApi = dataApiUrl,
        // Chart configuration
        scale = "linear",
        type = "doughnut",
        title = "kW/h today",
        labels = new string[] {
            "🍗 Oven",
            "🔥 Boiler",
            "❄️ Refrigerator",
            "🍹 Living Room",
            "📖 Study"
        },
        colors = new string[] {
            "rgb(197,137,64)",
            "rgb(229,186,115)",
            "rgb(250,234,177)",
            "rgb(255,247,218)",
            "rgb(255,253,244)"
        },
        refreshMs = 1800000, // 30 minutes
        // Other chart.js options (see https://www.chartjs.org/)
        options = new {
            scales = new {
                x = new {
                    display = false
                },
                y = new {
                    display = false
                }
            }
        }
    };
});

// API method implementation
Api.Handle(dataApiUrl, (args) =&gt; {
    // Just a demo, return fixed data
    return new double[] {
        700, 400, 200, 200, 100
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/ExamplePieChart";
const string dataApiUrl = "DataProcessing.Statistics/MyStat";

</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>pie-chart-stats-example</Id>
      <Version>1.0.2</Version>
      <Required>false</Required>
      <Checksum>D8F2F884BB3010580313BB3073D1347E</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>572</Address>
    <Name>Pie Chart Stats example</Name>
    <Description>Example chart provider that renders as a pie chart with static data.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.Enable", "Enable remote control", "checkbox")
  .AddFeature("", "Switch,Light,Dimmer,Color", "HomeGenie.RemoteControl.IRCode", "Toggle button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerUpCode", "ButtonUp", "1. Bright button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerDownCode", "ButtonDown", "2. Dim button (enter code)", "capture:Receiver.RawData")
  .AddOption("DimmerInterval", "10", "4. Dimming step %", "slider:5:50:5")
  .Run();
</ScriptSetup>
    <ScriptSource>var dimmerInterval = Program.Option("DimmerInterval");
var dimmerUp = Program.Option("DimmerUpCode");
var dimmerDown = Program.Option("DimmerDownCode");
var irControlModules = Modules.WithFeature("HomeGenie.RemoteControl.Enable");

When.ModuleParameterChanged((module, parameter) =&gt; {
  if(parameter.Name == "Receiver.RawData" )
  {
    var irData = parameter;
    var lastButton = module.Parameter("IrController.LastButton");
    var lastIdle = module.Parameter("IrController.LastIdle");
    var dimStep = dimmerInterval.DecimalValue / 100D;

    if (irData.Value != "")
    {
      if (lastButton.Value != "" &amp;&amp; lastIdle.IdleTime &gt; 0.25 &amp;&amp; (irData.Value == dimmerUp.Value || irData.Value == dimmerDown.Value))
      {
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == lastButton.Value)
          {
            var level = m.Level;
            if (irData.Value == dimmerUp.Value)
            {
              level += dimStep;
              m.Level = (level &gt;= 1 ? 1 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Bright (" + m.Level + ")");
            }
            else if (irData.Value == dimmerDown.Value)
            {
              level -= dimStep;
              m.Level = (level &lt;= 0.05 ? 0.05 : level);
              Program.Notify(m.Instance.Name + "&lt;br&gt;Dim (" + m.Level + ")");
            }
            lastIdle.Value = "0";
          }
          return false; // do not break, continue iterating...
        });
      }
      else
      {
        if (lastIdle.IdleTime &gt; 0.5)
        irControlModules.Each((m) =&gt; {
          var moduleButton = m.Parameter("HomeGenie.RemoteControl.IRCode");
          if (moduleButton.Value == irData.Value)
          {
            lastButton.Value = irData.Value;
            lastIdle.Value = "1";
            m.Toggle();
            Program.Notify(m.Instance.Name + "&lt;br&gt;toggled.");
          }
          return false; // do not break, continue iterating...
        });
      }
    }
  }
  return true;
});
Program.GoBackground();
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>remote-control</Id>
      <Version>1.0.2</Version>
      <Required>true</Required>
      <Checksum>F55B4203889EEC49B831E1F1AF765BCD</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>505</Address>
    <Name>Remote Control</Name>
    <Description>Toggle and dim the device using a remote controller (IR or RF).</Description>
    <Group>Lights</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.Enable</Property>
        <Description>Enable remote control</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>capture:Receiver.RawData</FieldType>
        <ForDomains />
        <ForTypes>Switch,Light,Dimmer,Color</ForTypes>
        <Property>HomeGenie.RemoteControl.IRCode</Property>
        <Description>Toggle button (enter code)</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.UseWidget("homegenie/generic/sensor");
//Program.Run();</ScriptSetup>
    <ScriptSource>#using NWaves.Signals.Builders
// For NWaves DSP library documentation see:
// https://github.com/ar1st0crat/NWaves?tab=readme-ov-file

DiscreteSignal sinusoid =
    new SineBuilder()
        .SetParameter("frequency", 200/*Hz*/)
        .SetParameter("phase", Math.PI)
        .OfLength(444)
        .SampledAt(44444/*Hz*/)
        .Build();

var samples = new List&lt;float&gt;(sinusoid.Samples);
while (Program.IsRunning)
{
    foreach (var s in samples)
    {
        double v = (s * .5) + .5;
        Program.Emit("Sensor.SineWave", v * 1000);
        // synchronize level of a module with sinewave values [0.0 .. 1.0]
        /*
        Program.RunAsyncTask(()=&gt;{
            Modules
                .WithAddress("S4")
                .Level = v;
        });
        */
        Pause(.05);
    }
}
</ScriptSource>
    <ScriptContext />
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>sine-wave-signal</Id>
      <Version>1.0.3</Version>
      <Required>false</Required>
      <Checksum>F09D3EDBC3FE43F726DEE5A8D7F496E2</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>900</Address>
    <Name>SineWave Signal</Name>
    <Description>Example</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>false</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>const string widget = "homegenie/generic/videoinput";
const string filter = "VideoInput,Sensor:Widget.DisplayModule=" + widget;

// FFMpeg Installation Check
if (!FfmpegHelper.IsAvailable())
{
  Program.Notify(
      $"The `{Program.Module.Name}` module requires **FFmpeg** to function.\n\n" +
      $"Please install it from the official website:\n\n" +
      $"- [https://ffmpeg.org](https://ffmpeg.org)\n\n" +
      $"If you do not need this feature, you can disable this module\n\n" +
      $"in the **Automation Programs** section or by clicking the button below" +
      $"[program_disable,translate=NOTIFY.ffmpeg_required]"
  );
  Pause(15);
  return false;
}

Program.Setup(() =&gt; {
  Program
    .AddModules(MediaVideoDomain, 1, VideoModulesCount, "VideoInput", widget)
    .AddFeature(MediaVideoDomain, filter, VideoInputDisable, "0. Disable this input", "checkbox")
    .AddFeature(MediaVideoDomain, filter, VideoInputSourceUrl, "1. Video Source URL", "text")
    .AddFeature(MediaVideoDomain, filter, VideoInputImageFeed, "2. URL is a live-updated single image file", "checkbox")
    .AddFeature(MediaVideoDomain, filter, VideoInputUsername, "3. Username (optional)", "text")
    .AddFeature(MediaVideoDomain, filter, VideoInputPassword, "4. Password (optional)", "password")
    .AddFeature(MediaVideoDomain, filter, WidgetConfigFps, "5. Max frames per second", "slider:1:30:1:5")
    .AddFeature(MediaVideoDomain, filter, VideoOutputWidth, "6. Output stream width", "slider:160:3840:160:640")
    .AddFeature(MediaVideoDomain, filter, SnapshotQuality, "7. Live image quality", "slider:1:31:1:5");
});

Program.Run();
</ScriptSetup>
    <ScriptSource>// --- GLOBAL STATE ---
// Caches active FFmpeg streamers and last known frames per camera module
var frameCache = new Dictionary&lt;string, VideoInputCacheEntry&gt;();
object dictionaryLock = new object();
string baseOutputPath = Path.Combine(Data.GetFolder(), "..", "..", "media", "live");

// Set default feature values
Modules.InDomain(MediaVideoDomain).Each((m) =&gt; {
    if (!m.HasFeature(VideoOutputWidth))
    {
        m.SetParameter(VideoOutputWidth, "640");
    }
    if (!m.HasFeature(SnapshotQuality))
    {
        m.SetParameter(SnapshotQuality, "5");
    }
    if (!m.HasFeature(WidgetConfigFps))
    {
        m.SetParameter(WidgetConfigFps, "5");
    }
    if (!m.HasParameter("NVR.Status.Recording"))
    {
        m.SetParameter("NVR.Status.Recording", "0");
    }
    return false;
});

// Thread-safe retrieval or creation of a camera's cache entry
var GetVideoInputCacheEntry = new Func&lt;string, VideoInputCacheEntry&gt;((videoFolder) =&gt; {
    VideoInputCacheEntry cacheEntry = null;
    lock (dictionaryLock)
    {
        if (!frameCache.TryGetValue(videoFolder, out cacheEntry))
        {
            cacheEntry = new VideoInputCacheEntry();
            frameCache[videoFolder] = cacheEntry;
        }
    }
    return cacheEntry;
});

// Main configurator: reads module params and applies them to the FFmpeg streamer
var checkStreamer = (string videoFolder, ModuleHelper module) =&gt; {

    // 1. Read configurations
    bool inputDisabled = module.Parameter(VideoInputDisable).Value == "On";
    string feedUrl = module.Parameter(VideoInputSourceUrl).Value;
    string user = module.Parameter(VideoInputUsername).Value;
    string pass = module.Parameter(VideoInputPassword).Value;
    double fpsVal = module.Parameter(WidgetConfigFps).DecimalValue;
    if (fpsVal &lt;= 0.1) fpsVal = 1;

    // Determine if FFmpeg should Pull from URL or wait for Pushed frames from C#
    string ffmpegMode = (module.Parameter(VideoInputImageFeed).Value == "On") ? InputModePush : InputModePull;
    var inputMode = (ffmpegMode == InputModePush) ? FfmpegInputMode.Push : FfmpegInputMode.Pull;

    // 2. Output params setup (HLS Live stream &amp; UI Snapshot)
    bool hlsEnabled = true;
    bool snapshotEnabled = true;
    string hlsOutputPath = Path.Combine(baseOutputPath, videoFolder);
    string snapshotOutputPath = Path.Combine(baseOutputPath, videoFolder, "image.jpg");

    if (!Directory.Exists(hlsOutputPath))
    {
        Directory.CreateDirectory(hlsOutputPath);
    }

    VideoInputCacheEntry cacheEntry = GetVideoInputCacheEntry(videoFolder);

    // 3. Apply config and start/stop streamer
    if (!inputDisabled &amp;&amp; (hlsEnabled || snapshotEnabled))
    {
        if (cacheEntry.Streamer == null) cacheEntry.Streamer = new FfmpegStreamer(Net);

        int hlsTime = 3; int hlsListSize = 4;
        int outputWidth = (int)module.Parameter(VideoOutputWidth).DecimalValue;
        int snapshotQuality = (int)module.Parameter(SnapshotQuality).DecimalValue;

        // Configure() handles restarting FFmpeg internally ONLY if params actually changed
        cacheEntry.Streamer.Configure(
            inputMode, feedUrl, user, pass, (int)fpsVal, outputWidth,
            hlsEnabled, hlsOutputPath, hlsTime, hlsListSize,
            snapshotEnabled, snapshotOutputPath, snapshotQuality
        );

        if (!cacheEntry.Streamer.IsRunning)
        {
            cacheEntry.Streamer.Start();

            // Publish HLS stream details for NVR/Recorder modules
            string playlistPath = Path.Combine(hlsOutputPath, "playlist.m3u8");
            int preBufferDuration = hlsTime * hlsListSize;

            if (playlistPath != module.Parameter("NVR.StreamPath").Value)
            {
                module.Emit("NVR.StreamPath", playlistPath);
                module.Emit("NVR.StreamBuffer", preBufferDuration);
            }
        }
    }
    else
    {
        if (cacheEntry.Streamer != null) cacheEntry.Streamer.Stop();
    }
};

// --- EVENT LISTENERS ---

// Listen for errors reported by the NVR recorder (e.g., live stream died). Force a check/restart.
When.ModuleParameterChanged((module, parameter) =&gt; {
    if (module.Instance.Domain == MediaVideoDomain &amp;&amp; parameter.Is("NVR.Status.Error") &amp;&amp; parameter.Value == "encoder_not_ready")
    {
        string videoFolder = Path.Combine(module.Instance.Domain.Replace(":", "@"), module.Instance.Address);
        checkStreamer(videoFolder, module);
        module.Emit("NVR.Status.Error", ""); // reset state
    }
    return true;
});


// --- REST API INTERFACE ---

// Handle all UI/Frontend requests in "Media.Video" domain
Api.Handle($"{MediaVideoDomain}/", ( args ) =&gt; {
  var request = Api.Parse(args);
  object responseData = new ResponseStatus(Status.Error, "An error occurred processing this request.");

  try
  {
    string videoFolder = Path.Combine(request.Domain.Replace(":", "@"), request.Address);
    string command = request.Command;

    VideoInputCacheEntry cacheEntry = GetVideoInputCacheEntry(videoFolder);

    var inputModules = Modules.InDomain(MediaVideoDomain);
    var module = inputModules.WithAddress(request.Address).Get();
    if (module == null) return responseData;

    // Ensure streamer is running before fulfilling the request
    checkStreamer(videoFolder, module);

    switch(command)
    {
      case "Camera.GetPicture":
        bool inputDisabled = module.Parameter(VideoInputDisable).Value == "On";
        if (inputDisabled) return null;
        bool snapshotEnabled = true;
        string snapshotOutputPath = Path.Combine(baseOutputPath, videoFolder, "image.jpg");

        if (snapshotEnabled &amp;&amp; !string.IsNullOrEmpty(snapshotOutputPath))
        {
            responseData = null; // Clear default error response
            try
            {
                if (File.Exists(snapshotOutputPath))
                {
                    DateTime lastWriteTime = File.GetLastWriteTimeUtc(snapshotOutputPath);
                    TimeSpan fileAge = DateTime.UtcNow - lastWriteTime;

                    if (fileAge.TotalSeconds &gt; 5 &amp;&amp; !cacheEntry.Streamer.IsRunning)
                    {
                        // Snapshot is stale AND FFmpeg is dead. Delete stale file and attempt restart.
                        try { File.Delete(snapshotOutputPath); } catch (IOException) { /* ignored */ }
                        cacheEntry.Streamer.Start();
                    }
                    else
                    {
                        // File is fresh, OR FFmpeg is running but delayed (e.g., waiting for keyframe).
                        byte[] fileBytes = File.ReadAllBytes(snapshotOutputPath);
                        cacheEntry.HttpImageData = fileBytes;
                        responseData = fileBytes;
                    }
                }
            }
            catch (IOException)
            {
                // ignored
            }

            if (responseData == null &amp;&amp; cacheEntry.HttpImageData != null)
            {
                // fallback to last good frame
                responseData = cacheEntry.HttpImageData;
            }
        }
        else
        {
            // Fallback logic
            if (cacheEntry.HttpImageData != null) responseData = cacheEntry.HttpImageData;
        }
        break;
    }
  }
  catch (Exception e)
  {
    Program.Notify("Video Input ERROR!", e.Message);
  }
  return responseData;
});

When.ProgramStopping(() =&gt;
{
    foreach(var entry in frameCache.Values)
    {
        if (entry.Streamer != null) entry.Streamer.Stop();
    }
    frameCache.Clear();
    return true;
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>#using System.Diagnostics

const int VideoModulesCount = 5;
const string MediaVideoDomain = "Media.Video";
const string VideoInputDisable = "VideoInput.Disable";
const string VideoInputSourceUrl = "VideoInput.SourceURL";
const string VideoInputImageFeed = "VideoInput.ImageFeed";
const string VideoInputUsername = "VideoInput.Username";
const string VideoInputPassword = "VideoInput.Password";
const string VideoOutputWidth = "VideoOutput.Width";
const string SnapshotQuality = "VideoOutput.SnapshotQuality";
const string WidgetConfigFps = "Widget.Config.fps";

const string InputModePush = "Push";
const string InputModePull = "Pull";

public class VideoInputCacheEntry
{
    public byte[] HttpImageData { get; set; }
    public DateTime LastHttpFetch { get; set; }

    public object HttpSyncRoot { get; set; } = new object();
    public bool IsInitializing { get; set; } = true;

    public FfmpegStreamer Streamer { get; set; }
}

public enum FfmpegInputMode
{
    Pull, // FFmpeg connects to a URL
    Push  // C# pushes frames into FFmpeg
}

public class FfmpegStreamer
{
    private Process _process;
    private FfmpegInputMode _mode;

    // Configuration properties
    private string _url, _user, _pass;
    private int _fps, _width;
    private int _hlsTime, _hlsListSize;
    private int _snapshotQuality;
    private bool _enableHls, _enableSnapshot;
    private string _hlsOutputPath, _snapshotOutputPath;

    private CancellationTokenSource _cts;
    private byte[] _lastFrame;
    private readonly object _frameLock = new object();

    public bool IsRunning { get; private set; } = false;
    private bool _configurationChanged = false;
    private NetHelper netHelper;

    // Event to notify parent if the process dies unexpectedly
    public event EventHandler ProcessExited;

    public FfmpegStreamer(NetHelper net)
    {
        netHelper = net;
    }

    public void Configure(FfmpegInputMode mode, string url, string user, string pass, int fps, int width,
                          bool enableHls, string hlsOutputPath, int hlsTime, int hlsListSize,
                          bool enableSnapshot, string snapshotOutputPath, int snapshotQuality)
    {
        // Restart ffmpeg if configuration changed
        if (mode != _mode || url != _url || fps != _fps || width != _width
            || enableHls != _enableHls || hlsOutputPath != _hlsOutputPath
            || hlsTime != _hlsTime || hlsListSize != _hlsListSize
            || enableSnapshot != _enableSnapshot || snapshotOutputPath != _snapshotOutputPath
            || snapshotQuality != _snapshotQuality)
        {
            _configurationChanged = true;
            Stop();

            _mode = mode; _url = url; _user = user; _pass = pass; _fps = fps; _width = width;
            _enableHls = enableHls; _hlsOutputPath = hlsOutputPath;
            _hlsTime = hlsTime;
            _hlsListSize = hlsListSize;
            _enableSnapshot = enableSnapshot; _snapshotOutputPath = snapshotOutputPath;
            _snapshotQuality = snapshotQuality;
        }
    }

    public void Start()
    {
        if (IsRunning) return;

        if (_mode == FfmpegInputMode.Pull &amp;&amp; string.IsNullOrEmpty(_url)) return;
        if (!_enableHls &amp;&amp; !_enableSnapshot) return;

        IsRunning = true;
        if (_configurationChanged)
        {
            _configurationChanged = false;
            Thread.Sleep(3000);
        }
        _cts = new CancellationTokenSource();

        var argsBuilder = new StringBuilder();

        // CORREZIONE: Mettiamo -y (overwrite) QUI, così vale per TUTTI i modi (Push e Pull).
        // Essenziale ora che non cancelliamo più la cartella intera.
        argsBuilder.Append("-y ");

        // --- INPUT CONFIGURATION ---
        if (_mode == FfmpegInputMode.Push)
        {
            // Push mode: FFmpeg expects a JPEG image stream from Standard Input
            argsBuilder.Append($"-framerate {_fps} -f image2pipe -vcodec mjpeg -i - ");
        }
        else // Pull mode
        {
            string inputUrl = _url;
            bool isNetworkStream = inputUrl.Contains("://");
            bool isRtsp = inputUrl.StartsWith("rtsp", StringComparison.OrdinalIgnoreCase);

            // Infinite loop for local files to prevent "10-second loop" issue
            if (!isNetworkStream)
            {
                argsBuilder.Append("-stream_loop -1 ");
            }

            if (isNetworkStream)
            {
                if (isRtsp)
                    argsBuilder.Append("-rtsp_transport tcp -st_timeout 5000000 ");
                else
                    argsBuilder.Append("-reconnect 1 -reconnect_at_eof 1 -reconnect_streamed 1 -reconnect_delay_max 5 ");
            }
            else
            {
                // -re reads the input at native framerate
                argsBuilder.Append("-re ");
            }

            argsBuilder.Append($"-i \"{inputUrl}\" ");
        }

        // --- OUTPUT CONFIGURATION ---
        PrepareOutputDirectories();

        argsBuilder.Append("-loglevel error ");

        if (_enableHls)
        {
            string hlsFilters = $"fps={_fps}";
            if (_width &gt; 0) hlsFilters += $",scale={_width}:-2";

            string playlistPath = Path.Combine(_hlsOutputPath, "playlist.m3u8");

            int gop = _fps * 2;

            argsBuilder.Append($"-map 0:v -map 0:a? -vf \"{hlsFilters}\" -c:v libx264 -preset ultrafast -tune zerolatency -crf 28 -pix_fmt yuv420p -g {gop} -sc_threshold 0 -c:a aac -b:a 128k ");
            argsBuilder.Append($"-f fifo -fifo_format hls -drop_pkts_on_overflow 1 -attempt_recovery 1 -recover_any_error 1 ");
            argsBuilder.Append($"-format_opts \"hls_time={_hlsTime}:hls_list_size={_hlsListSize}:hls_flags=delete_segments\" \"{playlistPath}\" ");
        }

        if (_enableSnapshot)
        {
            string snapshotFilters = $"fps={(_fps &lt; 30 ? _fps : 30)}";
            if (_width &gt; 0) snapshotFilters += $",scale={_width}:-2";

            argsBuilder.Append($"-vf \"{snapshotFilters}\" -fps_mode cfr -f image2 -update 1 -atomic_writing 1 -q:v {_snapshotQuality} \"{_snapshotOutputPath}\"");
        }

        try
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = "ffmpeg",
                Arguments = argsBuilder.ToString(),
                RedirectStandardInput = (_mode == FfmpegInputMode.Push),
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            _process = new Process { StartInfo = startInfo };

            _process.ErrorDataReceived += (s, e) =&gt; {
                if (!string.IsNullOrWhiteSpace(e.Data))
                {
                    Console.WriteLine($"FFMPEG ERR [{_url}]: {e.Data}");
                }
            };

            _process.Start();
            _process.BeginErrorReadLine();

            Task.Run(() =&gt; MonitorProcessAsync(_cts.Token));

            if (_mode == FfmpegInputMode.Push)
            {
                Task.Run(() =&gt; FetchLoopAsync(_cts.Token));
                Task.Run(() =&gt; FeedLoopAsync(_cts.Token));
            }
        }
        catch (Exception ex)
        {
            IsRunning = false;
        }
    }

    /// &lt;summary&gt;
    /// Monitors the FFmpeg process to detect unexpected exits.
    /// &lt;/summary&gt;
    private async Task MonitorProcessAsync(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested &amp;&amp; _process != null)
            {
                if (_process.HasExited)
                {
                    IsRunning = false;
                    ProcessExited?.Invoke(this, EventArgs.Empty);
                    break;
                }
                await Task.Delay(1000, ct);
            }
        }
        catch {}
    }

    private async Task FetchLoopAsync(CancellationToken ct)
    {
        int intervalMs = (int)Math.Ceiling(1000.0 / _fps);

        while (!ct.IsCancellationRequested &amp;&amp; _process != null &amp;&amp; !_process.HasExited)
        {
            if (string.IsNullOrWhiteSpace(_url))
            {
                await Task.Delay(1000, ct);
                continue;
            }

            var watch = Stopwatch.StartNew();
            try
            {
                // Async download
                byte[] newBytes = await Task.Run(() =&gt;
                    netHelper.WebService(_url).WithCredentials(_user, _pass).GetBytes(), ct);

                if (newBytes != null &amp;&amp; newBytes.Length &gt; 0)
                {
                    lock (_frameLock)
                    {
                        _lastFrame = newBytes;
                    }
                }
            }
            catch
            {
                // Log fetch error
            }

            watch.Stop();

            // Calculate delay to maintain download refresh rate
            int delay = intervalMs - (int)watch.ElapsedMilliseconds;
            if (delay &gt; 0)
                await Task.Delay(delay, ct);
        }
    }

    private async Task FeedLoopAsync(CancellationToken ct)
    {
        int intervalMs = (int)Math.Ceiling(1000.0 / _fps);

        while (!ct.IsCancellationRequested &amp;&amp; _process != null &amp;&amp; !_process.HasExited)
        {
            var watch = Stopwatch.StartNew();

            byte[] frameToSend = null;
            lock (_frameLock)
            {
                frameToSend = _lastFrame;
            }

            if (frameToSend != null)
            {
                try
                {
                    // Write to FFmpeg pipe
                    await _process.StandardInput.BaseStream.WriteAsync(frameToSend, 0, frameToSend.Length, ct);
                    await _process.StandardInput.BaseStream.FlushAsync(ct);
                }
                catch
                {
                    // If pipe is broken, stop
                    break;
                }
            }

            watch.Stop();

            // Precise timing for constant feed
            int delay = intervalMs - (int)watch.ElapsedMilliseconds;
            if (delay &gt; 0)
                await Task.Delay(delay, ct);
            else
                await Task.Yield(); // Force thread yield if lagging
        }
    }

    public void Stop()
    {
        IsRunning = false; // Flag immediately
        _cts?.Cancel();

        if (_process != null)
        {
            try
            {
                if (!_process.HasExited &amp;&amp; _mode == FfmpegInputMode.Push)
                {
                    _process.StandardInput.Close();
                }
            }
            catch { /* ignored */ }

            try
            {
                if (!_process.HasExited)
                {
                    if (!_process.WaitForExit(2000))
                    {
                        _process.Kill(true);
                    }
                }
            }
            catch { /* ignored */ }
        }

        _process = null;
        _cts = null;
    }

    private void PrepareOutputDirectories()
    {
        // Safe creation
        if (!string.IsNullOrEmpty(_hlsOutputPath)) Directory.CreateDirectory(_hlsOutputPath);
        if (!string.IsNullOrEmpty(_snapshotOutputPath)) Directory.CreateDirectory(Path.GetDirectoryName(_snapshotOutputPath));

        // Cleanup: Remove old files only, DO NOT delete the directory itself to avoid 404 errors on the client side
        try
        {
            if (Directory.Exists(_hlsOutputPath))
            {
                foreach (var file in Directory.GetFiles(_hlsOutputPath, "*.m3u8")) File.Delete(file);
                foreach (var file in Directory.GetFiles(_hlsOutputPath, "*.ts")) File.Delete(file);
            }
        }
        catch {}
    }
}

public static class FfmpegHelper
{
    private static bool? _isAvailable = null;

    public static bool IsAvailable()
    {
        if (_isAvailable.HasValue) return _isAvailable.Value;

        try
        {
            var p = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "ffmpeg",
                    Arguments = "-version",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                }
            };

            p.Start();
            p.WaitForExit(2000);

            _isAvailable = (p.ExitCode == 0);
        }
        catch (Exception)
        {
            _isAvailable = false;
        }

        return _isAvailable.Value;
    }
}
</ScriptContext>
    <ScriptErrors>[]</ScriptErrors>
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>video-input</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>9E89B7B28FEDACA61ABCD0BC30FEBBC8</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>200</Address>
    <Name>Video Input</Name>
    <Description>Captures audio and video streams for live monitoring, real-time processing, and continuous recording.</Description>
    <Group>Devices and Things</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoInput.Disable</Property>
        <Description>0. Disable this input</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>text</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoInput.SourceURL</Property>
        <Description>1. Video Source URL</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoInput.ImageFeed</Property>
        <Description>2. URL is a live-updated single image file</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>text</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoInput.Username</Property>
        <Description>3. Username (optional)</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>password</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoInput.Password</Property>
        <Description>4. Password (optional)</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>slider:1:30:1:5</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>Widget.Config.fps</Property>
        <Description>5. Max frames per second</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>slider:160:3840:160:640</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoOutput.Width</Property>
        <Description>6. Output stream width</Description>
      </ProgramFeature>
      <ProgramFeature>
        <FieldType>slider:1:31:1:5</FieldType>
        <ForDomains>Media.Video</ForDomains>
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>VideoOutput.SnapshotQuality</Property>
        <Description>7. Live image quality</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>CSharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Setup(() =&gt; {

  Program
    .AddFeature(
      "",
      VideoInputType,
      RecordOnAlarm,
      "Record On Alarm",
      "checkbox"
    );

});
Program.Run();
</ScriptSetup>
    <ScriptSource>// Dictionary to track active workers using Module Address as Key
var activeWorkers = new Dictionary&lt;string, CameraWorker&gt;();

// Define the dynamic collection ONCE outside the loop
var videoModules = Modules.OfDeviceType(VideoInputType);

// Ensure cleanup on stop/update
When.ProgramStopping(() =&gt; {
    Program.Notify("NVR System", "Stopping all recorders...");
    // Stop all running workers safely
    // We convert values to a list to avoid modification errors during enumeration
    var workerList = new List&lt;CameraWorker&gt;(activeWorkers.Values);
    foreach (var w in workerList)
    {
        w.Stop(0, true);
    }
    activeWorkers.Clear();
    return true;
});


Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.Start", (args) =&gt; {
    var request = Api.Parse(args);
    var cameraModule = Modules
        .InDomain(WebUtility.UrlDecode(request.Domain))
        .WithAddress(WebUtility.UrlDecode(request.Address))
        .Get();
    if (cameraModule.Exists)
    {
        cameraModule.Emit(ContinuousRecording, "On");
        return new ResponseStatus(Status.Ok);
    }
    return null;
});

Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.Stop", (args) =&gt; {
    var request = Api.Parse(args);
    var cameraModule = Modules
        .InDomain(WebUtility.UrlDecode(request.Domain))
        .WithAddress(WebUtility.UrlDecode(request.Address))
        .Get();
    if (cameraModule.Exists)
    {
        cameraModule.Emit(ContinuousRecording, "");
        return new ResponseStatus(Status.Ok);
    }
    return null;
});

Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.Check", (args) =&gt; {
    if (!Int32.TryParse(args?.ToString(), out int daysToDelete))
    {
        daysToDelete = 7;
    }
    var deletedFolders = new List&lt;string&gt;();
    videoModules.Each((module) =&gt; {
        var mr = new ModuleReference(){ Domain = module.Instance.Domain, Address = module.Instance.Address };
        string folder = NvrHelper.GetSafeModulePath(Data.GetFolder(RecordingsFolder), mr);
        deletedFolders.AddRange(NvrHelper.DeleteOldDirectories(folder, daysToDelete));
        return false; // Continue iteration
    });
    return deletedFolders;
});

Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.List", (args) =&gt; {
    var request = Api.Parse(args);
    var cameraModule = Modules
        .InDomain(WebUtility.UrlDecode(request.Domain))
        .WithAddress(WebUtility.UrlDecode(request.Address))
        .Get();
    if (cameraModule.Exists)
    {
        return NvrHelper.GetRecordings(Data.GetFolder(RecordingsFolder), cameraModule, request.Command);
    }
    return null;
});


Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.Days", (args) =&gt; {
    var request = Api.Parse(args);
    var cameraModule = Modules
        .InDomain(WebUtility.UrlDecode(request.Domain))
        .WithAddress(WebUtility.UrlDecode(request.Address))
        .Get();
    if (cameraModule.Exists)
    {
        return NvrHelper.GetRecordingFolders(Data.GetFolder(RecordingsFolder), cameraModule);
    }
    return null;
});


Api.Handle("HomeAutomation.HomeGenie/NVR/Recordings.Thumbnail", (args) =&gt; {
    var request = Api.Parse(args);

    var cameraModule = Modules
        .InDomain(WebUtility.UrlDecode(request.Domain))
        .WithAddress(WebUtility.UrlDecode(request.Address))
        .Get();

    if (cameraModule.Exists)
    {
        try
        {
            // Command contains the date (e.g. "20260215")
            string dateFolder = request.Command;

            // GetOption(0) contains the time of the folder (e.g. "103336")
            string timeFolder = request.GetOption(0);

            // GetOption(1) contains the offset in seconds (e.g. "15" or "10.5")
            string offsetStr = request.GetOption(1);
            // Basic parameter validation
            if (!string.IsNullOrEmpty(dateFolder) &amp;&amp;
                !string.IsNullOrEmpty(timeFolder) &amp;&amp;
                !string.IsNullOrEmpty(offsetStr))
            {
                double offset = 0;
                // Safe parsing of doubles (Culture invariant for semicolon handling)
                double.TryParse(offsetStr, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out offset);

                // Thumbnail URL Generation
                return ThumbnailHelper.GetThumbnailWithCache(Data.GetFolder(RecordingsFolder), cameraModule, dateFolder, timeFolder, offset);
            }
        }
        catch (Exception ex)
        {
            return new { Error = ex.Message };
        }
    }

    return request; // empy object {}
});


// Main loop to monitor configuration changes
while (Program.IsRunning)
{
    try
    {
        // List to keep track of modules that SHOULD be running in this iteration
        var validAddresses = new List&lt;string&gt;();

        // 1. ITERATE DYNAMIC COLLECTION &amp; START NEW WORKERS
        videoModules.Each((module) =&gt; {
            string cameraId = module.Instance.Domain + ":" + module.Instance.Address;
            validAddresses.Add(cameraId);

            // If we don't have a worker for this address yet, create and start it
            if (!activeWorkers.ContainsKey(cameraId))
            {
                try
                {
                    //Program.Notify("NVR System", "Starting new worker for: " + cameraId);
                    var worker = new CameraWorker(Data.GetFolder(RecordingsFolder), Modules, module.Instance.Domain, module.Instance.Address);
                    worker.Start();
                    activeWorkers.Add(cameraId, worker);
                }
                catch (Exception ex)
                {
                    Program.Notify("NVR Error", "Failed to start " + cameraId + ": " + ex.Message);
                }
            }
            return false; // Continue iteration
        });

        // 2. STOP OBSOLETE WORKERS
        var workersToRemove = new List&lt;string&gt;();

        foreach (var kvp in activeWorkers)
        {
            string workerAddr = kvp.Key;

            // If the active worker is NOT in the list we just built, it means the feature was disabled
            if (!validAddresses.Contains(workerAddr))
            {
                //Program.Notify("NVR System", "Feature disabled. Stopping worker: " + workerAddr);
                kvp.Value.Stop(0, true);
                workersToRemove.Add(workerAddr);
            }
        }

        // 3. CLEANUP DICTIONARY
        foreach (var addr in workersToRemove)
        {
            activeWorkers.Remove(addr);
        }
    }
    catch (Exception ex)
    {
        Program.Notify("NVR Loop Error", ex.Message);
    }

    // Check for configuration changes every 5 seconds.
    Pause(5);
}</ScriptSource>
    <ScriptContext>#using System.Diagnostics

const string RecordOnAlarm = "NVR.RecordOnAlarm";
const string ContinuousRecording = "NVR.ContinuousRecording";

const string VideoInputType = "VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput";

static string RecordingsFolder = Path.Combine("..", "media", "nvr");

/// &lt;summary&gt;
/// Worker class responsible for capturing video streams or frames from a specific camera module.
/// It handles recording lifecycles, hourly file rotation, watchdog monitoring, and frame pacing.
/// &lt;/summary&gt;
public class CameraWorker
{
    // --- Constants for Parameter Names ---
    private const string ParamStreamPath = "NVR.StreamPath";
    private const string ParamStreamBuffer = "NVR.StreamBuffer";
    private const string ParamFps = "Widget.Config.fps";
    private const string ParamRecordOnAlarm = "NVR.RecordOnAlarm";     // Assumed name based on context
    private const string ParamContinuous = "NVR.ContinuousRecording";  // Assumed name based on context
    private const string ParamStatusError = "NVR.Status.Error";
    private const string ParamStatusRecording = "NVR.Status.Recording";
    private const string CmdGetPicture = "Camera.GetPicture";

    // --- Core Dependencies ---
    private readonly ModulesManager _modules;
    private readonly ModuleReference _moduleRef = new ModuleReference();
    private readonly FFmpegRecorder _recorder;
    private Thread _workerThread;

    // --- State Flags ---
    private volatile bool _shouldStop = false;

    // --- Configurations ---
    private readonly double _defaultFps = 15.0;
    private string _baseOutputFolder;

    /// &lt;summary&gt;
    /// Initializes a new instance of the camera worker.
    /// &lt;/summary&gt;
    /// &lt;param name="outputFolder"&gt;The root directory for NVR recordings.&lt;/param&gt;
    /// &lt;param name="modules"&gt;The global modules manager.&lt;/param&gt;
    /// &lt;param name="moduleDomain"&gt;The domain of the camera module.&lt;/param&gt;
    /// &lt;param name="moduleAddress"&gt;The address of the camera module.&lt;/param&gt;
    public CameraWorker(string outputFolder, ModulesManager modules, string moduleDomain, string moduleAddress)
    {
        _modules = modules;
        _moduleRef.Domain = moduleDomain;
        _moduleRef.Address = moduleAddress;

        _recorder = new FFmpegRecorder();

        // Resolve the specific output path for this camera
        _baseOutputFolder = NvrHelper.GetSafeModulePath(outputFolder, _moduleRef);
    }

    /// &lt;summary&gt;
    /// Starts the capture loop in a background thread.
    /// &lt;/summary&gt;
    public void Start()
    {
        if (_workerThread != null &amp;&amp; _workerThread.IsAlive) return;

        _shouldStop = false;
        _workerThread = new Thread(CaptureLoop)
        {
            IsBackground = true,
            Name = $"Worker[{_moduleRef.Domain}:{_moduleRef.Address}]"
        };
        _workerThread.Start();
    }

    /// &lt;summary&gt;
    /// Stops the capture loop and finalizes the recording.
    /// &lt;/summary&gt;
    public void Stop(int delay, bool forceImmediate)
    {
        _shouldStop = true;
        if (_workerThread != null &amp;&amp; _workerThread.IsAlive)
        {
            // Wait gracefully, then force if necessary
            if (!_workerThread.Join(2000))
                _workerThread.Interrupt();
        }
        _recorder.Stop(0, forceImmediate);
    }

    /// &lt;summary&gt;
    /// Main loop handling the logic for fetching frames, monitoring state, and managing FFmpeg.
    /// &lt;/summary&gt;
    private void CaptureLoop()
    {
        // Use TickCount64 to track frame pacing and avoid drift over time
        long nextFrameTick = Environment.TickCount64;

        DateTime lastRestartHour = DateTime.MinValue;
        DateTime lastRecordingPing = DateTime.MinValue;
        DateTime lastErrorTs = DateTime.MinValue;

        bool isFrameByFrameMode = false;
        byte[] lastValidFrame = null;

        while (!_shouldStop)
        {
            try
            {
                // Always refresh the module reference to handle external restarts/updates of the Video Input program
                var module = _modules
                    .InDomain(_moduleRef.Domain)
                    .WithAddress(_moduleRef.Address)
                    .Get();

                if (module == null)
                {
                    Thread.Sleep(1000);
                    continue;
                }

                // --- 1. Read Parameters ---
                var localStreamPath = module.Parameter(ParamStreamPath);
                var preBufferSeconds = module.Parameter(ParamStreamBuffer);

                double fps = module.Parameter(ParamFps).DecimalValue;
                if (fps &lt;= 0) fps = _defaultFps;

                // If no stream path is provided, we fall back to frame-by-frame (GetPicture) mode
                isFrameByFrameMode = string.IsNullOrWhiteSpace(localStreamPath.Value);

                var recordOnAlarmParam = module.Parameter(ParamRecordOnAlarm);
                var continuousRecordingParam = module.Parameter(ParamContinuous);

                // --- 2. Frame Pacing (FPS Control) ---
                long nowTick = Environment.TickCount64;
                int waitMs = (int)(nextFrameTick - nowTick);

                // Minimum sleep to prevent CPU spinning, even if we are behind schedule
                if (waitMs &lt; 5) waitMs = 5;
                Thread.Sleep(waitMs);

                int frameIntervalMs = (int)((1.0 / fps) * 1000);
                nextFrameTick += frameIntervalMs;

                // Drift Correction: If we are lagging significantly (&gt; 2 seconds),
                // reset the timer to current time to avoid a burst of catch-up frames.
                if (nowTick &gt; nextFrameTick + 2000)
                {
                    nextFrameTick = nowTick + frameIntervalMs;
                }

                // --- 3. Trigger Logic ---
                bool recordOnAlarm = (recordOnAlarmParam.Value == "On");
                bool continuousRecording = (continuousRecordingParam.Value == "On");

                bool isTriggered = continuousRecording || (recordOnAlarm &amp;&amp; IsAlarmed(module));
                DateTime now = DateTime.Now;

                // --- 4. Watchdog / Error Reporting ---
                // If we should be recording but the recorder isn't active, report an error periodically.
                if (isTriggered &amp;&amp; !_recorder.IsRecording &amp;&amp; ((now - lastErrorTs).TotalSeconds &gt; 15))
                {
                    lastErrorTs = now;
                    module.Emit(ParamStatusError, "encoder_not_ready");
                }

                // --- Start/Stop &amp; Hourly Logic ---

                // Determine mode early (needed for both Start logic and Frame pushing later)
                bool canUseCopyMode = !string.IsNullOrWhiteSpace(localStreamPath.Value);

                // 1. Start/Stop Logic
                // We handle this FIRST to ensure we restart immediately after an hourly cut
                if (isTriggered &amp;&amp; !_recorder.IsRecording &amp;&amp; (now - lastRestartHour).TotalSeconds &gt; 10)
                {
                    lastRestartHour = now; // Mark session start (resets the debounce timer)
                    lastErrorTs = now;

                    if (canUseCopyMode)
                    {
                        // Mode A: Stream Copy
                        _recorder.Start(_baseOutputFolder, fps, localStreamPath.Value, preBufferSeconds.DecimalValue);
                    }
                    else
                    {
                        // Mode B: Frame-by-Frame
                        _recorder.Start(_baseOutputFolder, fps);
                    }
                }
                else if (!isTriggered &amp;&amp; _recorder.IsRecording)
                {
                    // Stop if trigger ceased
                    _recorder.Stop((int)(preBufferSeconds.DecimalValue * 1000));
                    module.Emit(ParamStatusRecording, "0");
                    lastErrorTs = now;
                }

                // 2. Hourly Recording Segmentation
                // Check if we need to rotate the file.
                // We do NOT update 'lastRestartHour' here to allow the 'Start Logic' above
                // to trigger immediately in the next loop iteration.
                if ((now.Minute == 0 &amp;&amp; now.Second &lt; 5 &amp;&amp; now.Hour != lastRestartHour.Hour) || _shouldStop)
                {
                    if (_recorder.IsRecording)
                    {
                        // Stop current segment, keeping the pre-buffer
                        _recorder.Stop((int)(preBufferSeconds.DecimalValue * 1000));
                        module.Emit(ParamStatusRecording, "0");
                    }

                    if (_shouldStop) break;
                }

                // Update UI status
                if (isTriggered &amp;&amp; _recorder.IsRecording &amp;&amp; module.Parameter(ParamStatusRecording).Value == "0")
                {
                    module.Emit(ParamStatusRecording, "1");
                }

                // --- 7. Frame Processing (Frame-by-Frame Mode) ---
                if (_recorder.IsRecording &amp;&amp; !canUseCopyMode)
                {
                    byte[] currentFrame = (byte[])module.Command(CmdGetPicture).GetValue();

                    if (currentFrame != null &amp;&amp; currentFrame.Length &gt; 0)
                    {
                        lastValidFrame = currentFrame;
                        _recorder.PushFrame(lastValidFrame);
                    }
                    else if (lastValidFrame != null)
                    {
                        // Fallback: If fetch fails, duplicate the last valid frame to maintain video continuity (prevent black frames)
                        _recorder.PushFrame(lastValidFrame);
                    }

                    if ((now - lastRecordingPing).TotalSeconds &gt; 10)
                    {
                        lastRecordingPing = now;
                    }
                }
            }
            catch (Exception)
            {
                // In case of transient errors, try to keep the recording alive by pushing the last known frame
                if (_recorder.IsRecording &amp;&amp; isFrameByFrameMode &amp;&amp; lastValidFrame != null)
                {
                    _recorder.PushFrame(lastValidFrame);
                }
                // Short pause to prevent tight error loops
                Thread.Sleep(500);
            }
        }

        // Cleanup on exit
        _recorder.Stop(0);

        var m = _modules
                .InDomain(_moduleRef.Domain)
                .WithAddress(_moduleRef.Address)
                .Get();
        m?.Emit(ParamStatusRecording, "0");
    }

    /// &lt;summary&gt;
    /// Checks if the motion or object sensors are currently active or within the buffer window.
    /// &lt;/summary&gt;
    private bool IsAlarmed(ModuleHelper module)
    {
        double preBufferSeconds = module.Parameter(ParamStreamBuffer).DecimalValue;

        // Keep recording for 'buffer' seconds + 2 extra seconds after the event ends
        double timeThreshold = preBufferSeconds + 2;

        var motionSensor = module.Parameter("Sensor.MotionDetect");
        var objectSensor = module.Parameter("Sensor.ObjectDetect");

        // Check if value &gt; 0 and if the last update was recent enough (IdleTime)
        bool isMotionActive = (motionSensor.DecimalValue &gt; 0) &amp;&amp; (motionSensor.IdleTime &lt;= timeThreshold);
        bool isObjectActive = (objectSensor.DecimalValue &gt; 0) &amp;&amp; (objectSensor.IdleTime &lt;= timeThreshold);

        return isMotionActive || isObjectActive;
    }
}

public class FFmpegRecorder
{
    private Process _ffmpegProcess;
    private Stream _ffmpegInputStream;
    private bool _isRecording = false;

    private string _ffmpegErrorLog = "";

    private int _segmentDuration = 25; // Segments of 25 seconds
    private int _playlistSize = 0;     // Keep 360 segments = 3600 seconds = 1 hour
                                       // NOTE: Setting to 0 would keep ALL segments until stream ends.
                                       //       360 is for "up to one hour" for the playlist duration.
    private double _preBufferSeconds = 0;
    private string _videoCodec = "libx264";

    private string _currentRecordingSessionFolder = "";
    private string _currentOutputMp4File = "";

    public bool IsRecording
    {
        get { return _isRecording &amp;&amp; _ffmpegProcess != null &amp;&amp; !_ffmpegProcess.HasExited; }
    }

    /// &lt;summary&gt;
    /// Starts the FFmpeg recording process, creating a timestamped subfolder for each session.
    /// &lt;/summary&gt;
    /// &lt;param name="outputBaseFolder"&gt;Base folder for all recordings (e.g., "html/cam_rec/CameraSensor")&lt;/param&gt;
    /// &lt;param name="fps"&gt;Expected frame rate from the main loop&lt;/param&gt;
    public void Start(string outputBaseFolder, double fps, string livePlaylistPath = null, double preBufferSeconds = 0)
    {
        if (IsRecording) return;

        if (Directory.Exists(_currentRecordingSessionFolder))
        {
            // delete directory if empty (failed previous session)
            if (Directory.GetFiles(_currentRecordingSessionFolder).Length == 0
                &amp;&amp; Directory.GetDirectories(_currentRecordingSessionFolder).Length == 0)
            {
                Directory.Delete(_currentRecordingSessionFolder);
            }
        }

        _currentRecordingSessionFolder = Path.Combine(outputBaseFolder, DateTime.Now.ToString("yyyyMMdd"), DateTime.Now.ToString("HHmmss"));
        _preBufferSeconds = preBufferSeconds;
        _currentOutputMp4File = "";

        if (!Directory.Exists(_currentRecordingSessionFolder))
        {
            Directory.CreateDirectory(_currentRecordingSessionFolder);
        }

        string playlistPath = Path.Combine(_currentRecordingSessionFolder, "playlist.m3u8");
        string args = "";

        if (livePlaylistPath != null)
        {
            // TODO: include input/source name in filename
            string outputFilePath = _currentOutputMp4File = Path.Combine(
                _currentRecordingSessionFolder,
                "rec_" + DateTime.Now.ToString("yyyyMMdd")
                    + "_" + DateTime.Now.ToString("HHmmss")
                    + "_" + preBufferSeconds + ".mp4"
            );
            args = $"-y " +
                $"-live_start_index 0 " +
                $"-i \"{livePlaylistPath}\" " +
//                $"-map 0:v:0 -map 0:a:0 " +
                $"-c:v copy -c:a copy -f hls -hls_time 10 -hls_list_size 0 -hls_segment_type mpegts -hls_flags independent_segments " +
                $"\"{playlistPath}\" " +
                $"-f mp4 -movflags +faststart \"{outputFilePath}\"";
        }
        else
        {
            int gop = (int)Math.Round(fps * _segmentDuration);
            args = $"-y -f image2pipe -vcodec mjpeg -r {fps} -i - " +
                $"-c:v {_videoCodec} -an -r {fps} -preset ultrafast -crf 23 -pix_fmt yuv420p -g {gop} " +
                $"-f hls -hls_time {_segmentDuration} -hls_list_size {_playlistSize} " +
                $"\"{playlistPath}\"";
        }

        ProcessStartInfo psi = new ProcessStartInfo
        {
            FileName = "ffmpeg",
            Arguments = args,
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        try
        {
            _ffmpegProcess = new Process();
            _ffmpegProcess.StartInfo = psi;

            // Register event handlers for output/error
            _ffmpegProcess.OutputDataReceived += (sender, e) =&gt; { if (e.Data != null) _ffmpegErrorLog += e.Data + Environment.NewLine; };
            _ffmpegProcess.ErrorDataReceived += (sender, e) =&gt; { if (e.Data != null) _ffmpegErrorLog += "ERROR: " + e.Data + Environment.NewLine; };

            _ffmpegProcess.Start();
            _ffmpegProcess.BeginOutputReadLine(); // Start reading async
            _ffmpegProcess.BeginErrorReadLine();  // Start reading async

            _ffmpegInputStream = _ffmpegProcess.StandardInput.BaseStream;
            _isRecording = true;
        }
        catch (Exception ex)
        {
            _isRecording = false;
            // Now you can log the FFmpeg output/error log if it fails to start
            //Program.Notify("FFmpeg Startup Error", "Check FFmpeg command/path. FFmpeg Log:\n" + _ffmpegErrorLog + "\nException: " + ex.Message);
            throw;
        }
    }

    // Method to retrieve the log:
    public string GetFFmpegLog()
    {
        return _ffmpegErrorLog;
    }

    /// &lt;summary&gt;
    /// Pushes a single image frame (JPEG byte array) to the FFmpeg pipe.
    /// &lt;/summary&gt;
    public void PushFrame(byte[] imageBytes)
    {
        if (!IsRecording) return;
        try
        {
            _ffmpegInputStream.Write(imageBytes, 0, imageBytes.Length);
            _ffmpegInputStream.Flush();
        }
        catch (Exception)
        {
            Stop(0);
        }
    }

    /// &lt;summary&gt;
    /// Stops the recording process and terminates FFmpeg.
    /// &lt;/summary&gt;
    public void Stop(int delay = 0, bool forceImmediate = false)
    {
        if (!_isRecording) return;

        var ouputFile = _currentOutputMp4File;
        var process = _ffmpegProcess;

        _ffmpegProcess = null;
        _ffmpegInputStream = null;
        _isRecording = false;
        _currentRecordingSessionFolder = "";
        _currentOutputMp4File = "";

        Action killAction = () =&gt; {
            try
            {
                if (delay &gt; 0 &amp;&amp; !forceImmediate)
                {
                    Thread.Sleep(delay);
                }

                if (process != null &amp;&amp; !process.HasExited)
                {
                    // Send the character 'q' to FFmpeg's Standard Input
                    if (process.StartInfo.RedirectStandardInput)
                    {
                        try
                        {
                            process.StandardInput.WriteLine("q");
                            process.StandardInput.Close();
                        }
                        catch { /* Ignored */ }
                    }

                    process.WaitForExit(forceImmediate ? 1000 : 10000);

                    // last resort
                    if (!process.HasExited)
                    {
                        try { process.Kill(); } catch { }
                    }

                    process.Dispose();

                    // remove live playlist.*
                    try
                    {
                        var dir = new DirectoryInfo(Path.Combine(Path.GetDirectoryName(ouputFile)));
                        if (dir.Exists)
                        {
                            foreach (var file in dir.EnumerateFiles("playlist*")) {
                                file.Delete();
                            }
                        }
                    } catch { }

                    if (!string.IsNullOrWhiteSpace(ouputFile) &amp;&amp; !forceImmediate)
                    {
                        MediaInfoService.GetMediaInfo(ouputFile);
                    }
                }
            }
            catch { /* Ignored */ }
        };

        if (forceImmediate)
        {
            killAction();
        }
        else
        {
            Task.Run(killAction);
        }
    }
}

public class NvrHelper
{
    public class RecordingSession
    {
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public TimeSpan Duration { get { return EndTime - StartTime; } }
        public string PlaylistPath { get; set; }
        public string FolderName { get; set; }
        public long SizeBytes { get; set; }
        public string MediaSummary { get; set; }
    }

    public class RecordingFolder
    {
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public int TotalTime { get; set; }
        public long TotalSize { get; set; }
        public int SessionCount { get; set; }
        public string FolderName { get; set; }
    }

    public static string GetSafeModulePath(string outputFolder, ModuleReference mr)
    {
        string safeDomain = System.Text.RegularExpressions.Regex.Replace(mr.Domain.Replace(":", "@"), "[^a-zA-Z0-9_+\\-().@]", "");
        string safeName = System.Text.RegularExpressions.Regex.Replace(mr.Address, "[^a-zA-Z0-9_+\\-().@]", "");
        return Path.Combine(outputFolder, safeDomain, safeName);
    }

    public static List&lt;RecordingSession&gt; GetRecordings(string nvrBasePath, ModuleHelper videoModule, string dateFilter = null)
    {
        var mr = new ModuleReference(){ Domain = videoModule.Instance.Domain, Address = videoModule.Instance.Address };
        var sessions = new List&lt;RecordingSession&gt;();
        string camPath = GetSafeModulePath(nvrBasePath, mr);
        if (!Directory.Exists(camPath)) return sessions;

        var dayDirs = Directory.GetDirectories(camPath);

        foreach (var dayDir in dayDirs)
        {
            string dayName = new DirectoryInfo(dayDir).Name;
            if (!string.IsNullOrEmpty(dateFilter) &amp;&amp; dayName != dateFilter) continue;

            if (!DateTime.TryParseExact(dayName, "yyyyMMdd", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateBase))
                continue;

            var timeDirs = Directory.GetDirectories(dayDir);

            foreach (var timeDir in timeDirs)
            {
                string timeName = new DirectoryInfo(timeDir).Name;

                if (!DateTime.TryParseExact(timeName, "HHmmss", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime sessionBaseTime))
                    continue;

                DateTime baseStart = dateBase.Date + sessionBaseTime.TimeOfDay;
                baseStart = DateTime.SpecifyKind(baseStart, DateTimeKind.Local);

                string playlistPath = Path.Combine(timeDir, "playlist.m3u8");
                var mp4Files = Directory.GetFiles(timeDir, "rec_*.mp4");

                bool playlistExists = File.Exists(playlistPath);
                bool mp4Exists = mp4Files.Length &gt; 0;
                bool usePlaylist = false;

                // --- SMART LOGIC: Live vs Archive ---
                if (playlistExists)
                {
                    DateTime lastWrite = File.GetLastWriteTime(playlistPath);
                    double minutesSinceLastUpdate = (DateTime.Now - lastWrite).TotalMinutes;

                    // If the playlist was updated recently (e.g., &lt; 2 mins ago),
                    // we assume the recording is ACTIVE (Live). We MUST use the playlist.
                    if (minutesSinceLastUpdate &lt; 2.0)
                    {
                        usePlaylist = true;
                    }
                    // If the playlist is old (stale) AND we have an MP4,
                    // it means the recording crashed or finished without cleanup.
                    // We discard the playlist and use the MP4.
                    else if (mp4Exists)
                    {
                        try
                        {
                            File.Delete(playlistPath);
                            var tsFiles = Directory.GetFiles(timeDir, "*.ts");
                            foreach (var ts in tsFiles) File.Delete(ts);
                        }
                        catch { /* Ignore locks */ }

                        usePlaylist = false;
                    }
                    else
                    {
                        // Playlist is old but NO MP4 exists?
                        // We have no choice but to try using the playlist (HLS-only recording).
                        usePlaylist = true;
                    }
                }

                if (usePlaylist)
                {
                    double totalDurationSeconds = GetDurationFromPlaylist(playlistPath);
                    DateTime fullEnd = baseStart.AddSeconds(totalDurationSeconds);

                    sessions.Add(new RecordingSession
                    {
                        StartTime = baseStart.ToUniversalTime(),
                        EndTime = fullEnd.ToUniversalTime(),
                        PlaylistPath = playlistPath,
                        FolderName = $"{dayName}/{timeName}"
                    });
                }
                else if (mp4Exists)
                {
                    foreach (var mp4Path in mp4Files)
                    {
                        // Logic to extract PreBuffer info from filename: rec_YYYYMMDD_HHMMSS_PREBUFFER.mp4
                        string fileName = Path.GetFileNameWithoutExtension(mp4Path);
                        string[] parts = fileName.Split('_');

                        int preBuffer = 0;
                        if (parts.Length &gt;= 4)
                        {
                            int.TryParse(parts[3], out preBuffer);
                        }

                        // Subtract PreBuffer to find the actual event start
                        DateTime adjustedStart = baseStart.AddSeconds(-preBuffer);

                        var mediaInfo = MediaInfoService.GetMediaInfo(mp4Path);
                        double duration = mediaInfo.TotalDuration;
                        DateTime adjustedEnd = adjustedStart.AddSeconds(duration);

                        // Safety check for metadata inconsistencies
                        if (adjustedEnd &lt; adjustedStart) adjustedEnd = adjustedStart.AddSeconds(preBuffer + 5);

                        // --- Media Info for UI ---
                        long sizeBytes = 0;
                        long.TryParse(mediaInfo.format?.size, out sizeBytes);

                        string mediaSummary = "N/A";
                        var videoStream = mediaInfo.VideoStream;
                        var audioStream = mediaInfo.AudioStream;

                        if (videoStream != null)
                        {
                            string fps = "";
                            if (!string.IsNullOrEmpty(videoStream.avg_frame_rate))
                            {
                                var fpsParts = videoStream.avg_frame_rate.Split('/');
                                if (fpsParts.Length == 2 &amp;&amp; double.TryParse(fpsParts[0], out double num) &amp;&amp; double.TryParse(fpsParts[1], out double den) &amp;&amp; den != 0)
                                {
                                    fps = $" • {Math.Round(num / den)} fps";
                                }
                            }

                            string audioCodec = audioStream != null &amp;&amp; !string.IsNullOrEmpty(audioStream.codec_name)
                                ? $"/{audioStream.codec_name}"
                                : "";

                            mediaSummary = $"{mediaInfo.VideoRes}{fps} • {videoStream.codec_name}{audioCodec}";
                        }

                        sessions.Add(new RecordingSession
                        {
                            StartTime = adjustedStart.ToUniversalTime(),
                            EndTime = adjustedEnd.ToUniversalTime(),
                            PlaylistPath = mp4Path,
                            FolderName = $"{dayName}/{timeName}",
                            SizeBytes = sizeBytes,
                            MediaSummary = mediaSummary
                        });
                    }
                }
            }
        }

        return sessions.OrderBy(s =&gt; s.StartTime).ToList();
    }

    public static List&lt;RecordingFolder&gt; GetRecordingFolders(string nvrBasePath, ModuleHelper videoModule)
    {
        var mr = new ModuleReference(){ Domain = videoModule.Instance.Domain, Address = videoModule.Instance.Address };
        var folders = new List&lt;RecordingFolder&gt;();
        string camPath = GetSafeModulePath(nvrBasePath, mr);
        if (!Directory.Exists(camPath)) return folders;

        var dayDirs = Directory.GetDirectories(camPath);

        foreach (var dayDir in dayDirs)
        {
            string dayName = new DirectoryInfo(dayDir).Name;
            if (!DateTime.TryParseExact(dayName, "yyyyMMdd", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateBase))
                continue;

            int sessionCount = 0;
            long totalSize = 0;
            double totalDurationSeconds = 0;
            DateTime? minStartTime = null;
            DateTime? maxEndTime = null;

            var timeDirs = Directory.GetDirectories(dayDir);
            foreach (var timeDir in timeDirs)
            {
                string timeName = new DirectoryInfo(timeDir).Name;
                if (!DateTime.TryParseExact(timeName, "HHmmss", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime sessionBaseTime))
                    continue;

                DateTime baseStart = dateBase.Date + sessionBaseTime.TimeOfDay;
                baseStart = DateTime.SpecifyKind(baseStart, DateTimeKind.Local);

                bool sessionFound = false;
                DateTime sessionStart = baseStart;
                DateTime sessionEnd = baseStart;
                double sessionDuration = 0;

                string playlistPath = Path.Combine(timeDir, "playlist.m3u8");
                var mp4Files = Directory.GetFiles(timeDir, "rec_*.mp4");

                bool playlistExists = File.Exists(playlistPath);
                bool mp4Exists = mp4Files.Length &gt; 0;
                bool usePlaylist = false;

                // --- DUPLICATED SMART LOGIC (Kept consistent with GetRecordings) ---
                if (playlistExists)
                {
                    DateTime lastWrite = File.GetLastWriteTime(playlistPath);
                    if ((DateTime.Now - lastWrite).TotalMinutes &lt; 2.0)
                    {
                        usePlaylist = true; // Active recording
                    }
                    else if (!mp4Exists)
                    {
                        usePlaylist = true; // No MP4 available
                    }
                    // Else: Stale playlist + MP4 exists -&gt; Fallthrough to MP4 logic
                }

                if (usePlaylist)
                {
                    sessionDuration = GetDurationFromPlaylist(playlistPath);
                    sessionEnd = baseStart.AddSeconds(sessionDuration);
                    sessionFound = true;
                }
                else if (mp4Exists)
                {
                    string mp4Path = mp4Files[0];
                    string[] parts = Path.GetFileNameWithoutExtension(mp4Path).Split('_');
                    int preBuffer = 0;
                    if (parts.Length &gt;= 4) int.TryParse(parts[3], out preBuffer);

                    sessionStart = baseStart.AddSeconds(-preBuffer);

                    var mediaInfo = MediaInfoService.GetMediaInfo(mp4Path);
                    sessionEnd = sessionStart.AddSeconds(mediaInfo.TotalDuration);

                    if (sessionEnd &lt; sessionStart) sessionEnd = sessionStart.AddSeconds(preBuffer + 5);

                    sessionDuration = (sessionEnd - sessionStart).TotalSeconds;
                    sessionFound = true;
                }

                if (sessionFound)
                {
                    sessionCount++;
                    totalDurationSeconds += sessionDuration;
                    totalSize += new DirectoryInfo(timeDir).EnumerateFiles("*", SearchOption.AllDirectories).Sum(fi =&gt; fi.Length);

                    if (minStartTime == null || sessionStart &lt; minStartTime) minStartTime = sessionStart;
                    if (maxEndTime == null || sessionEnd &gt; maxEndTime) maxEndTime = sessionEnd;
                }
            }

            if (sessionCount &gt; 0 &amp;&amp; minStartTime.HasValue &amp;&amp; maxEndTime.HasValue)
            {
                folders.Add(new RecordingFolder
                {
                    FolderName = dayName,
                    SessionCount = sessionCount,
                    StartTime = minStartTime.Value.ToUniversalTime(),
                    EndTime = maxEndTime.Value.ToUniversalTime(),
                    TotalTime = (int)Math.Round(totalDurationSeconds),
                    TotalSize = totalSize
                });
            }
        }

        return folders.OrderBy(f =&gt; f.FolderName).ToList();
    }

    private static double GetDurationFromPlaylist(string playlistPath)
    {
        double totalDurationSeconds = 0;
        try
        {
            string[] lines = File.ReadAllLines(playlistPath);
            foreach (string line in lines)
            {
                if (line.StartsWith("#EXTINF:"))
                {
                    int colonIndex = 8;
                    int commaIndex = line.IndexOf(',');
                    if (commaIndex &gt; colonIndex)
                    {
                        string durationStr = line.Substring(colonIndex, commaIndex - colonIndex);
                        if (double.TryParse(durationStr, NumberStyles.Any, CultureInfo.InvariantCulture, out double segmentDuration))
                        {
                            totalDurationSeconds += segmentDuration;
                        }
                    }
                }
            }
        }
        catch { return 0; }
        return totalDurationSeconds;
    }

    public static List&lt;string&gt; DeleteOldDirectories(string baseFolder, int daysToDeleteOlderThan)
    {
        var deletedFolders = new List&lt;string&gt;();
        if (!Directory.Exists(baseFolder))
        {
            return deletedFolders;
        }
        try
        {
            var directories = Directory.GetDirectories(baseFolder)
                                      .Select(dir =&gt; new DirectoryInfo(dir))
                                      .Where(dirInfo =&gt; dirInfo.Exists);
            DateTime cutoffDate = DateTime.Now.AddDays(-daysToDeleteOlderThan);
            var oldDirectories = directories.Where(dirInfo =&gt; dirInfo.CreationTimeUtc &lt; cutoffDate || dirInfo.LastWriteTimeUtc &lt; cutoffDate);
            foreach (var dirToDelete in oldDirectories)
            {
                try
                {
                    Directory.Delete(dirToDelete.FullName, true);
                    deletedFolders.Add(dirToDelete.FullName);
                }
                catch (Exception e)
                {
                    /* ignored */
                }
            }
        }
        catch (Exception ex)
        {
            /* ignored */
        }
        return deletedFolders;
    }
}

public static class MediaInfoService
{
    public static MediaMetadata GetMediaInfo(string videoPath)
    {
        string cachePath = videoPath + ".info";
        FileInfo videoFileInfo = new FileInfo(videoPath);
        FileInfo cacheFileInfo = new FileInfo(cachePath);

        if (File.Exists(cachePath) &amp;&amp; cacheFileInfo.LastWriteTimeUtc &gt;= videoFileInfo.LastWriteTimeUtc)
        {
            try {
                string jsonCache = File.ReadAllText(cachePath);
                return JsonSerializer.Deserialize&lt;MediaMetadata&gt;(jsonCache);
            } catch { /* Corrupted cache, proceed with ffprobe */ }
        }

        string jsonOutput = RunFFprobe(videoPath);

        var options = new JsonSerializerOptions { WriteIndented = true };
        File.WriteAllText(cachePath, jsonOutput);

        return JsonSerializer.Deserialize&lt;MediaMetadata&gt;(jsonOutput);
    }

    private static string RunFFprobe(string filePath)
    {
        var psi = new ProcessStartInfo
        {
            FileName = "ffprobe",
            Arguments = $"-v quiet -print_format json -show_format -show_streams \"{filePath}\"",
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using (var process = Process.Start(psi))
        {
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();
            return output;
        }
    }
}
public class MediaMetadata
{
    public List&lt;StreamInfo&gt; streams { get; set; }
    public FormatInfo format { get; set; }

    // Helpers
    public double TotalDuration =&gt; double.Parse(format?.duration ?? "0", System.Globalization.CultureInfo.InvariantCulture);
    public StreamInfo VideoStream =&gt; streams?.FirstOrDefault(s =&gt; s.codec_type == "video");
    public StreamInfo AudioStream =&gt; streams?.FirstOrDefault(s =&gt; s.codec_type == "audio");
    public string VideoRes =&gt; VideoStream != null ? $"{VideoStream.width}x{VideoStream.height}" : "N/A";
}

public class StreamInfo
{
    public string codec_name { get; set; }
    public string codec_type { get; set; }
    public string profile { get; set; }
    public int width { get; set; }
    public int height { get; set; }
    public string avg_frame_rate { get; set; }
    public string duration { get; set; }
    public Dictionary&lt;string, string&gt; tags { get; set; }
}

public class FormatInfo
{
    public string format_long_name { get; set; }
    public string duration { get; set; }
    public string size { get; set; }
    public string bit_rate { get; set; }
    public Dictionary&lt;string, string&gt; tags { get; set; }
}

public class ThumbnailHelper
{
    private static string _cacheFolder = "";

    private static string GetCacheFilePath(ModuleHelper module, string dateFolder, string timeFolder, double offset)
    {
        string rawId = $"{module.Instance.Domain}_{module.Instance.Address}_{dateFolder}_{timeFolder}_{offset}";
        string safeId = System.Text.RegularExpressions.Regex.Replace(rawId, "[^a-zA-Z0-9_]", "") + ".jpg";
        return Path.Combine(_cacheFolder, safeId);
    }

    // Returns the URL, using the cache
    public static byte[] GetThumbnailWithCache(string nvrBaseFolder, ModuleHelper module, string dateFolder, string timeFolder, double offset)
    {
        if (_cacheFolder == "")
        {
            _cacheFolder = Path.Combine(nvrBaseFolder, "cache");
        }
        string cacheFilePath = GetCacheFilePath(module, dateFolder, timeFolder, offset);
        if (!File.Exists(cacheFilePath))
        {
            byte[] thumbData = GenerateThumbnailBytes(nvrBaseFolder, module, dateFolder, timeFolder, offset);
            if (thumbData != null)
            {
                if (!Directory.Exists(_cacheFolder)) Directory.CreateDirectory(_cacheFolder);
                File.WriteAllBytes(cacheFilePath, thumbData);
            }
            return thumbData;
        }
        return File.ReadAllBytes(cacheFilePath);
    }

    // Returns the bytes, generating the file temporarily and then deleting it
    public static byte[] GetThumbnailBytes(string nvrBaseFolder, ModuleHelper module, string dateFolder, string timeFolder, double offset)
    {
        byte[] thumbData = GenerateThumbnailBytes(nvrBaseFolder, module, dateFolder, timeFolder, offset);
        return thumbData;
    }

    public static byte[] GenerateThumbnailBytes(string nvrBaseFolder, ModuleHelper videoModule, string dateFolder, string timeFolder, double offset)
    {
        var mr = new ModuleReference(){ Domain = videoModule.Instance.Domain, Address = videoModule.Instance.Address };
        string camPath = NvrHelper.GetSafeModulePath(nvrBaseFolder, mr);
        string timeDir = Path.Combine(camPath, dateFolder, timeFolder);
        string inputFilePath = Path.Combine(timeDir, "playlist.m3u8");
        // HLS Playlist
        if (!File.Exists(inputFilePath))
        {
            // MP4 File
            var mp4Files = Directory.GetFiles(timeDir, "rec_*.mp4");
            if (mp4Files.Length &gt; 0)
            {
                inputFilePath = mp4Files[0];
            }
        }

        if (!File.Exists(inputFilePath)) return null;

        string args = $"-ss {offset} -i \"{inputFilePath}\" -frames:v 1 -q:v 5 -f image2pipe -vcodec mjpeg -";

        var psi = new ProcessStartInfo
        {
            FileName = "ffmpeg",
            Arguments = args,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        try
        {
            using (var p = Process.Start(psi))
            {
                using (var ms = new MemoryStream())
                {
                    p.StandardOutput.BaseStream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
        }
        catch { return null; }
    }
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>video-recorder</Id>
      <Version>1.0.1</Version>
      <Required>true</Required>
      <Checksum>65B5F0EB261A81B8364054F7891D0F97</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>250</Address>
    <Name>Video Recorder</Name>
    <Description>Records audio and video streams from any input source. Recordings can be continuous, scheduled, or triggered by alarm events.</Description>
    <Group>Utilities</Group>
    <Features>
      <ProgramFeature>
        <FieldType>checkbox</FieldType>
        <ForDomains />
        <ForTypes>VideoInput,Sensor:Widget.DisplayModule=homegenie/generic/videoinput</ForTypes>
        <Property>NVR.RecordOnAlarm</Property>
        <Description>Record On Alarm</Description>
      </ProgramFeature>
    </Features>
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
  <ProgramBlock>
    <ScriptSetup>Program.Implements(
    "@Statistics:Provider",
    apiUrl,
    new {
        mode = "select_module",
        field = "Meter.Watts.Hour",
        type = "bar",
        title = "W/h",
        icon = "analytics"
    }
).Run();
</ScriptSetup>
    <ScriptSource>Api.Handle(apiUrl, (args) =&gt; {
    return new {
        dataApi = apiDataUrl,
        scale = "linear",
        labels = GetDayLabels(),
        refreshMs = 60000, // 1 minute
        browsing = true
    };
});

Program.GoBackground();
</ScriptSource>
    <ScriptContext>const string apiUrl = "Statistics.Providers/WeeklyStats";
const string apiDataUrl = "DataProcessing.Statistics/Weekly/Meter.Watts.Hour";

public string[] GetDayLabels()
{
    DayOfWeek[] desiredOrder = new DayOfWeek[]
    {
        DayOfWeek.Monday,    // 0
        DayOfWeek.Tuesday,   // 1
        DayOfWeek.Wednesday, // 2
        DayOfWeek.Thursday,  // 3
        DayOfWeek.Friday,    // 4
        DayOfWeek.Saturday,  // 5
        DayOfWeek.Sunday     // 6
    };
    DateTimeFormatInfo dtfi = CultureInfo.CurrentCulture.DateTimeFormat;
    string[] finalLabels = new string[7];
    for (int i = 0; i &lt; 7; i++)
    {
        DayOfWeek day = desiredOrder[i];
        int labelIndex = (int)day;
        finalLabels[i] = dtfi.AbbreviatedDayNames[labelIndex];
    }
    return finalLabels;
}
</ScriptContext>
    <ScriptErrors />
    <Data />
    <PackageInfo>
      <Repository>homegenie</Repository>
      <PackageId>homegenie-base</PackageId>
      <PackageVersion>1.0.5</PackageVersion>
      <Id>weekly-energy-use-chart</Id>
      <Version>1.0.0</Version>
      <Required>false</Required>
      <Checksum>B584D065DD0AE78A064665351C41495E</Checksum>
    </PackageInfo>
    <Domain>HomeAutomation.HomeGenie.Automation</Domain>
    <Address>573</Address>
    <Name>Weekly Energy Consumption</Name>
    <Description>Bar chart displaying the average Watts/Hour consumption for each day of the week (Mon-Sun). Data is aggregated across all hours of the day and sourced from the Energy Use Statistics API.</Description>
    <Group>Data Processing</Group>
    <Features />
    <AutoRestartEnabled>false</AutoRestartEnabled>
    <Cloneable>false</Cloneable>
    <Type>csharp</Type>
    <IsEnabled>true</IsEnabled>
  </ProgramBlock>
</ArrayOfProgramBlock>